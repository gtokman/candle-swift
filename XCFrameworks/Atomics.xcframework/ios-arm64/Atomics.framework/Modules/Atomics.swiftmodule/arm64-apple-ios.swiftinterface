// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-experimental-feature BuiltinModule -enable-bare-slash-regex -module-name Atomics -package-name swift_atomics
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Builtin
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension Swift.RawRepresentable where Self : Atomics.AtomicOptionalWrappable, Self.RawValue : Atomics.AtomicOptionalWrappable, Self.RawValue == Self.RawValue.AtomicRepresentation.Value {
  public typealias AtomicOptionalRepresentation = Atomics.AtomicOptionalRawRepresentableStorage<Self>
}
@frozen public struct AtomicOptionalRawRepresentableStorage<Wrapped> : Atomics.AtomicStorage where Wrapped : Swift.RawRepresentable, Wrapped.RawValue : Atomics.AtomicOptionalWrappable, Wrapped.RawValue == Wrapped.RawValue.AtomicRepresentation.Value {
  public typealias Value = Swift.Optional<Wrapped>
  @usableFromInline
  internal typealias _Storage = Wrapped.RawValue.AtomicOptionalRepresentation
  @usableFromInline
  internal var _storage: Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>._Storage
  @_transparent @_alwaysEmitIntoClient public init(_ value: __owned Swift.Optional<Wrapped>) {
    self._storage = _Storage(value?.rawValue)
  }
  @_transparent @_alwaysEmitIntoClient public __consuming func dispose() -> Swift.Optional<Wrapped> {
    _storage.dispose().flatMap(Wrapped.init(rawValue:))
  }
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>>) -> Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>._Storage> {
     
    return UnsafeMutableRawPointer(ptr).assumingMemoryBound(to: _Storage.self)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Optional<Wrapped> {
    let ro = _Storage.atomicLoad(
      at: _extract(pointer), ordering: ordering)
    return ro.flatMap(Wrapped.init(rawValue:))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: __owned Swift.Optional<Wrapped>, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>>, ordering: Atomics.AtomicStoreOrdering) {
    _Storage.atomicStore(
      desired?.rawValue, at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: __owned Swift.Optional<Wrapped>, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Optional<Wrapped> {
    let ro = _Storage.atomicExchange(
      desired?.rawValue, at: _extract(pointer), ordering: ordering)
    return ro.flatMap(Wrapped.init(rawValue:))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Optional<Wrapped>, desired: __owned Swift.Optional<Wrapped>, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Optional<Wrapped>) {
    let ro = _Storage.atomicCompareExchange(
      expected: expected?.rawValue,
      desired: desired?.rawValue,
      at: _extract(pointer),
      ordering: ordering)
    return (ro.exchanged, ro.original.flatMap(Wrapped.init(rawValue:)))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Optional<Wrapped>, desired: __owned Swift.Optional<Wrapped>, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Optional<Wrapped>) {
    let ro = _Storage.atomicCompareExchange(
      expected: expected?.rawValue,
      desired: desired?.rawValue,
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (ro.exchanged, ro.original.flatMap(Wrapped.init(rawValue:)))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Optional<Wrapped>, desired: __owned Swift.Optional<Wrapped>, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalRawRepresentableStorage<Wrapped>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Optional<Wrapped>) {
    let ro = _Storage.atomicWeakCompareExchange(
      expected: expected?.rawValue,
      desired: desired?.rawValue,
      at: _extract(pointer),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (ro.exchanged, ro.original.flatMap(Wrapped.init(rawValue:)))
  }
}
extension Swift.RawRepresentable where Self : Atomics.AtomicValue, Self.RawValue : Atomics.AtomicValue, Self.RawValue == Self.RawValue.AtomicRepresentation.Value {
  public typealias AtomicRepresentation = Atomics.AtomicRawRepresentableStorage<Self>
}
@frozen public struct AtomicRawRepresentableStorage<Value> : Atomics.AtomicStorage where Value : Swift.RawRepresentable, Value.RawValue : Atomics.AtomicValue, Value.RawValue == Value.RawValue.AtomicRepresentation.Value {
  @usableFromInline
  internal typealias _Storage = Value.RawValue.AtomicRepresentation
  @usableFromInline
  internal var _storage: Atomics.AtomicRawRepresentableStorage<Value>._Storage
  @_transparent @_alwaysEmitIntoClient public init(_ value: __owned Value) {
    _storage = _Storage(value.rawValue)
  }
  @_transparent @_alwaysEmitIntoClient public func dispose() -> Value {
    Value(rawValue: _storage.dispose())!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>>) -> Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>._Storage> {
     
    UnsafeMutableRawPointer(ptr).assumingMemoryBound(to: _Storage.self)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>>, ordering: Atomics.AtomicLoadOrdering) -> Value {
    let raw = _Storage.atomicLoad(at: _extract(pointer), ordering: ordering)
    return Value(rawValue: raw)!
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>>, ordering: Atomics.AtomicStoreOrdering) {
    _Storage.atomicStore(
      desired.rawValue, at: _extract(pointer), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>>, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let raw = _Storage.atomicExchange(
      desired.rawValue, at: _extract(pointer), ordering: ordering)
    return Value(rawValue: raw)!
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Value, desired: Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let raw = _Storage.atomicCompareExchange(
            expected: expected.rawValue,
            desired: desired.rawValue,
            at: _extract(pointer),
            ordering: ordering)
    return (raw.exchanged, Value(rawValue: raw.original)!)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Value, desired: Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let raw = _Storage.atomicCompareExchange(
            expected: expected.rawValue,
            desired: desired.rawValue,
            at: _extract(pointer),
            successOrdering: successOrdering,
            failureOrdering: failureOrdering)
    return (raw.exchanged, Value(rawValue: raw.original)!)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Value, desired: Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicRawRepresentableStorage<Value>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    let raw = _Storage.atomicWeakCompareExchange(
            expected: expected.rawValue,
            desired: desired.rawValue,
            at: _extract(pointer),
            successOrdering: successOrdering,
            failureOrdering: failureOrdering)
    return (raw.exchanged, Value(rawValue: raw.original)!)
  }
}
extension Swift.Bool {
  @_alwaysEmitIntoClient @_transparent internal init(_ builtin: Builtin.Int1) {
    self = unsafeBitCast(builtin, to: Bool.self)
  }
}
extension Swift.Bool : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Bool
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt8Storage
    @usableFromInline
    internal var _storage: Swift.Bool.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.Bool) {
      _storage = value._atomicRepresentation
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.Bool.AtomicRepresentation.Value {
      return _storage._decodeBool
    }
  }
}
extension Swift.Bool {
  @_transparent @_alwaysEmitIntoClient internal var _atomicRepresentation: Atomics._AtomicInt8Storage {
    @_transparent get {
    let v: Int8 = (self ? 1 : 0)
    return .init(v._value)
  }
  }
}
extension Atomics._AtomicInt8Storage {
  @_transparent @_alwaysEmitIntoClient internal var _decodeBool: Swift.Bool {
    @_transparent get {
    (Int8(self._value) & 1) != 0
  }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.Bool.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.Bool.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.Bool.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Bool {
    pointer._extract._atomicLoad(ordering: ordering)._decodeBool
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      desired._atomicRepresentation, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Bool {
    pointer._extract._atomicExchange(
      desired._atomicRepresentation, ordering: ordering
    )._decodeBool
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Bool, desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Bool) {
    let r = pointer._extract._atomicCompareExchange(
      expected: expected._atomicRepresentation,
      desired: desired._atomicRepresentation,
      ordering: ordering)
    return (r.exchanged, r.original._decodeBool)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Bool, desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Bool) {
    let r = pointer._extract._atomicCompareExchange(
      expected: expected._atomicRepresentation,
      desired: desired._atomicRepresentation,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, r.original._decodeBool)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Bool, desired: __owned Swift.Bool, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Bool) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: expected._atomicRepresentation,
      desired: desired._atomicRepresentation,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, r.original._decodeBool)
  }
}
extension Swift.Bool.AtomicRepresentation {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenLogicalAnd(with operand: Swift.Bool.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Bool.AtomicRepresentation.Value {
    pointer._extract._atomicLoadThenBitwiseAnd(
      with: operand._atomicRepresentation, ordering: ordering
    )._decodeBool
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenLogicalOr(with operand: Swift.Bool.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Bool.AtomicRepresentation.Value {
    pointer._extract._atomicLoadThenBitwiseOr(
      with: operand._atomicRepresentation, ordering: ordering
    )._decodeBool
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenLogicalXor(with operand: Swift.Bool.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Bool.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Bool.AtomicRepresentation.Value {
    pointer._extract._atomicLoadThenBitwiseXor(
      with: operand._atomicRepresentation, ordering: ordering
    )._decodeBool
  }
}
extension Atomics.UnsafeAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalAnd(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalOr(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalXor(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
}
extension Atomics.UnsafeAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalAndThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original && operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalOrThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original || operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalXorThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original != operand
  }
}
extension Atomics.ManagedAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalAnd(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalOr(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenLogicalXor(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
}
extension Atomics.ManagedAtomic where Value == Swift.Bool {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalAndThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original && operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalOrThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original || operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func logicalXorThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = Value.AtomicRepresentation.atomicLoadThenLogicalXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original != operand
  }
}
extension Swift.Int8 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int8
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt8Storage
    @usableFromInline
    internal var _storage: Swift.Int8.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.Int8.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.Int8.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int8.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int8.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.Int8.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.Int8.AtomicRepresentation._Storage) -> Swift.Int8.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Int8.AtomicRepresentation.Value) -> Swift.Int8.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.Int8.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Int8 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int8, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int8, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int8 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int8, desired: Swift.Int8, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int8) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int8, desired: Swift.Int8, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int8) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int8, desired: Swift.Int8, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int8) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.Int8 : Atomics.AtomicInteger {
}
extension Swift.Int8.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int8 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int8 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int8 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int8 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int8 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.Int16 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int16
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt16Storage
    @usableFromInline
    internal var _storage: Swift.Int16.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.Int16.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.Int16.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int16.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int16.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.Int16.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.Int16.AtomicRepresentation._Storage) -> Swift.Int16.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Int16.AtomicRepresentation.Value) -> Swift.Int16.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.Int16.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Int16 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int16, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int16, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int16 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int16, desired: Swift.Int16, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int16) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int16, desired: Swift.Int16, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int16) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int16, desired: Swift.Int16, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int16) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.Int16 : Atomics.AtomicInteger {
}
extension Swift.Int16.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int16 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int16 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int16 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int16 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int16 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.Int32 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int32
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt32Storage
    @usableFromInline
    internal var _storage: Swift.Int32.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.Int32.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.Int32.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int32.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int32.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.Int32.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.Int32.AtomicRepresentation._Storage) -> Swift.Int32.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Int32.AtomicRepresentation.Value) -> Swift.Int32.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.Int32.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Int32 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int32, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int32, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int32 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int32, desired: Swift.Int32, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int32) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int32, desired: Swift.Int32, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int32) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int32, desired: Swift.Int32, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int32) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.Int32 : Atomics.AtomicInteger {
}
extension Swift.Int32.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int32 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int32 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int32 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int32 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int32 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.Int64 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int64
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt64Storage
    @usableFromInline
    internal var _storage: Swift.Int64.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.Int64.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.Int64.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int64.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int64.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.Int64.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.Int64.AtomicRepresentation._Storage) -> Swift.Int64.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Int64.AtomicRepresentation.Value) -> Swift.Int64.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.Int64.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Int64 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int64, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int64, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int64 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int64, desired: Swift.Int64, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int64) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int64, desired: Swift.Int64, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int64) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int64, desired: Swift.Int64, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int64) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.Int64 : Atomics.AtomicInteger {
}
extension Swift.Int64.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int64 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int64 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int64 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int64 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int64 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.UInt8 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt8
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt8Storage
    @usableFromInline
    internal var _storage: Swift.UInt8.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UInt8.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UInt8.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt8.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt8.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.UInt8.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UInt8.AtomicRepresentation._Storage) -> Swift.UInt8.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UInt8.AtomicRepresentation.Value) -> Swift.UInt8.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.UInt8.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UInt8 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt8, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt8, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt8 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt8, desired: Swift.UInt8, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt8) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt8, desired: Swift.UInt8, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt8) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt8, desired: Swift.UInt8, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt8) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.UInt8 : Atomics.AtomicInteger {
}
extension Swift.UInt8.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt8 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt8 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt8 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt8 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt8 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt8.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt8 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.UInt16 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt16
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt16Storage
    @usableFromInline
    internal var _storage: Swift.UInt16.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UInt16.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UInt16.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt16.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt16.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.UInt16.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UInt16.AtomicRepresentation._Storage) -> Swift.UInt16.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UInt16.AtomicRepresentation.Value) -> Swift.UInt16.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.UInt16.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UInt16 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt16, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt16, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt16 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt16, desired: Swift.UInt16, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt16) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt16, desired: Swift.UInt16, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt16) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt16, desired: Swift.UInt16, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt16) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.UInt16 : Atomics.AtomicInteger {
}
extension Swift.UInt16.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt16 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt16 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt16 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt16 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt16 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt16.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt16 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.UInt32 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt32
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt32Storage
    @usableFromInline
    internal var _storage: Swift.UInt32.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UInt32.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UInt32.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt32.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt32.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.UInt32.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UInt32.AtomicRepresentation._Storage) -> Swift.UInt32.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UInt32.AtomicRepresentation.Value) -> Swift.UInt32.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.UInt32.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UInt32 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt32, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt32, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt32 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt32, desired: Swift.UInt32, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt32) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt32, desired: Swift.UInt32, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt32) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt32, desired: Swift.UInt32, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt32) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.UInt32 : Atomics.AtomicInteger {
}
extension Swift.UInt32.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt32 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt32 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt32 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt32 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt32 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt32.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt32 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.UInt64 : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt64
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicInt64Storage
    @usableFromInline
    internal var _storage: Swift.UInt64.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UInt64.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UInt64.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt64.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt64.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.UInt64.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UInt64.AtomicRepresentation._Storage) -> Swift.UInt64.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UInt64.AtomicRepresentation.Value) -> Swift.UInt64.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.UInt64.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UInt64 {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt64, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt64, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt64 {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt64, desired: Swift.UInt64, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt64) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt64, desired: Swift.UInt64, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt64) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt64, desired: Swift.UInt64, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt64) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.UInt64 : Atomics.AtomicInteger {
}
extension Swift.UInt64.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt64 {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt64 {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt64 {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt64 {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt64 = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt64.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt64 {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.Int : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Int
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal var _storage: Swift.Int.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.Int.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.Int.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.Int.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.Int.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.Int.AtomicRepresentation._Storage) -> Swift.Int.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Int.AtomicRepresentation.Value) -> Swift.Int.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.Int.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Int {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Int, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Int, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int, desired: Swift.Int, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Int) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Int, desired: Swift.Int, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Int, desired: Swift.Int, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Int) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.Int : Atomics.AtomicInteger {
}
extension Swift.Int.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.Int = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.Int = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.Int = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.Int = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.Int = 1, at pointer: Swift.UnsafeMutablePointer<Swift.Int.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Int {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Swift.UInt : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UInt
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal var _storage: Swift.UInt.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UInt.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UInt.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Swift.UInt.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Swift.UInt.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UInt.AtomicRepresentation._Storage) -> Swift.UInt.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UInt.AtomicRepresentation.Value) -> Swift.UInt.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Swift.UInt.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UInt {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UInt, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UInt, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt, desired: Swift.UInt, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UInt, desired: Swift.UInt, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UInt, desired: Swift.UInt, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UInt) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.UInt : Atomics.AtomicInteger {
}
extension Swift.UInt.AtomicRepresentation : Atomics.AtomicIntegerStorage {
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingIncrement(by operand: Swift.UInt = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt {
    let r = pointer._extract._atomicLoadThenWrappingIncrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenWrappingDecrement(by operand: Swift.UInt = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt {
    let r = pointer._extract._atomicLoadThenWrappingDecrement(
      by: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseAnd(with operand: Swift.UInt = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt {
    let r = pointer._extract._atomicLoadThenBitwiseAnd(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseOr(with operand: Swift.UInt = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt {
    let r = pointer._extract._atomicLoadThenBitwiseOr(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
  @discardableResult
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoadThenBitwiseXor(with operand: Swift.UInt = 1, at pointer: Swift.UnsafeMutablePointer<Swift.UInt.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UInt {
    let r = pointer._extract._atomicLoadThenBitwiseXor(
      with: Self._encode(operand), ordering: ordering)
    return Self._decode(r)
  }
}
extension Atomics.DoubleWord : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Atomics.DoubleWord
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicDoubleWordStorage
    @usableFromInline
    internal var _storage: Atomics.DoubleWord.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Atomics.DoubleWord.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Atomics.DoubleWord.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Atomics.DoubleWord.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Atomics.DoubleWord.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal var _extract: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation._Storage> {
    @_transparent get {
     
     
    UnsafeMutableRawPointer(self).assumingMemoryBound(to: Pointee._Storage.self)
  }
  }
}
#endif
extension Atomics.DoubleWord.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Atomics.DoubleWord.AtomicRepresentation._Storage) -> Atomics.DoubleWord.AtomicRepresentation.Value {
    return Value(storage._value)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Atomics.DoubleWord.AtomicRepresentation.Value) -> Atomics.DoubleWord.AtomicRepresentation._Storage {
    return _Storage(value._value)
  }
}
extension Atomics.DoubleWord.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Atomics.DoubleWord {
    let r = pointer._extract._atomicLoad(ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Atomics.DoubleWord, at pointer: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    pointer._extract._atomicStore(
      Self._encode(desired),
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Atomics.DoubleWord, at pointer: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Atomics.DoubleWord {
    let r = pointer._extract._atomicExchange(
      Self._encode(desired),
      ordering: ordering)
    return Self._decode(r)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Atomics.DoubleWord, desired: Atomics.DoubleWord, at pointer: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics.DoubleWord) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      ordering: ordering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Atomics.DoubleWord, desired: Atomics.DoubleWord, at pointer: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics.DoubleWord) {
    let r = pointer._extract._atomicCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Atomics.DoubleWord, desired: Atomics.DoubleWord, at pointer: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics.DoubleWord) {
    let r = pointer._extract._atomicWeakCompareExchange(
      expected: Self._encode(expected),
      desired: Self._encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (r.exchanged, Self._decode(r.original))
  }
}
extension Swift.UnsafeRawPointer : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafeRawPointer
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeRawPointer.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
extension Swift.UnsafeRawPointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafeRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafeRawPointer.AtomicRepresentation._Storage) -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafeRawPointer(bitPattern: bits)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeRawPointer.AtomicRepresentation.Value) -> Swift.UnsafeRawPointer.AtomicRepresentation._Storage {
    let bits = Int(bitPattern: value)
    return _Storage(bits._value)
  }
}
extension Swift.UnsafeRawPointer.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafeRawPointer.AtomicRepresentation.Value {
    let v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeMutableRawPointer : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafeMutableRawPointer
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeMutableRawPointer.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafeMutableRawPointer.AtomicRepresentation._Storage) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafeMutableRawPointer(bitPattern: bits)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation._Storage {
    let bits = Int(bitPattern: value)
    return _Storage(bits._value)
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value {
    let v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafePointer<Pointee>
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafePointer<Pointee>.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#else
extension Swift.UnsafePointer : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafePointer<Pointee>
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafePointer<Pointee>.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#endif
extension Swift.UnsafePointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafePointer<Pointee>.AtomicRepresentation._Storage) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafePointer(bitPattern: bits)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation._Storage {
    let bits = Int(bitPattern: value)
    return _Storage(bits._value)
  }
}
extension Swift.UnsafePointer.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value {
    let v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafeMutablePointer<Pointee>
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#else
extension Swift.UnsafeMutablePointer : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.UnsafeMutablePointer<Pointee>
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
#endif
extension Swift.UnsafeMutablePointer.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafeMutablePointer.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation._Storage) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafeMutablePointer(bitPattern: bits)!
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation._Storage {
    let bits = Int(bitPattern: value)
    return _Storage(bits._value)
  }
}
extension Swift.UnsafeMutablePointer.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value {
    let v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.Unmanaged : Atomics.AtomicValue {
  @frozen public struct AtomicRepresentation {
    public typealias Value = Swift.Unmanaged<Instance>
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.Unmanaged<Instance>.AtomicRepresentation._Storage
    @_transparent @_alwaysEmitIntoClient public init(_ value: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @_transparent @_alwaysEmitIntoClient public func dispose() -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
      return Self._decode(_storage)
    }
  }
}
extension Swift.Unmanaged.AtomicRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>) -> Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.Unmanaged.AtomicRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.Unmanaged<Instance>.AtomicRepresentation._Storage) -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
    let bits = Int(storage._value)
    return Unmanaged.fromOpaque(UnsafeRawPointer(bitPattern: bits)!)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) -> Swift.Unmanaged<Instance>.AtomicRepresentation._Storage {
    let bits = Int(bitPattern: value.toOpaque())
    return _Storage(bits._value)
  }
}
extension Swift.Unmanaged.AtomicRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Unmanaged<Instance>.AtomicRepresentation.Value {
    let v = _extract(pointer)._atomicExchange(
      _encode(desired), ordering: ordering)
    return _decode(v)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeRawPointer : Atomics.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafeRawPointer?
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeRawPointer.AtomicOptionalRepresentation._Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
      Self._decode(_storage)
    }
  }
}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafeRawPointer.AtomicOptionalRepresentation._Storage) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafeRawPointer(bitPattern: bits)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation._Storage {
    let bits = value.map { Int(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeRawPointer.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.UnsafeMutableRawPointer : Atomics.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafeMutableRawPointer?
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation._Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
      Self._decode(_storage)
    }
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation._Storage) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafeMutableRawPointer(bitPattern: bits)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation._Storage {
    let bits = value.map { Int(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafePointer : Atomics.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafePointer<Pointee>?
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation._Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage)
    }
  }
}
#else
extension Swift.UnsafePointer : Atomics.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafePointer<Pointee>?
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation._Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage)
    }
  }
}
#endif
extension Swift.UnsafePointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation._Storage) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafePointer(bitPattern: bits)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation._Storage {
    let bits = value.map { Int(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}
extension Swift.UnsafePointer.AtomicOptionalRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer : Atomics.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafeMutablePointer<Pointee>?
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation._Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage)
    }
  }
}
#else
extension Swift.UnsafeMutablePointer : Atomics.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.UnsafeMutablePointer<Pointee>?
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation._Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage)
    }
  }
}
#endif
extension Swift.UnsafeMutablePointer.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.UnsafeMutablePointer.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation._Storage) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
    let bits = Int(storage._value)
    return UnsafeMutablePointer(bitPattern: bits)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation._Storage {
    let bits = value.map { Int(bitPattern: $0) } ?? 0
    return _Storage(bits._value)
  }
}
extension Swift.UnsafeMutablePointer.AtomicOptionalRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, desired: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.UnsafeMutablePointer<Pointee>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
extension Swift.Unmanaged : Atomics.AtomicOptionalWrappable {
  @frozen public struct AtomicOptionalRepresentation {
    public typealias Value = Swift.Unmanaged<Instance>?
    @usableFromInline
    internal typealias _Storage = Atomics._AtomicIntStorage
    @usableFromInline
    internal let _storage: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation._Storage
    @inline(__always) @_alwaysEmitIntoClient public init(_ value: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
      _storage = Self._encode(value)
    }
    @inline(__always) @_alwaysEmitIntoClient public func dispose() -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
      Self._decode(_storage)
    }
  }
}
extension Swift.Unmanaged.AtomicOptionalRepresentation {
  @usableFromInline
  @_transparent @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>) -> Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation._Storage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _Storage.self)
  }
}
extension Swift.Unmanaged.AtomicOptionalRepresentation {
  @_transparent @_alwaysEmitIntoClient internal static func _decode(_ storage: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation._Storage) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
    let bits = Int(storage._value)
    guard let opaque = UnsafeRawPointer(bitPattern: bits) else {
      return nil
    }
    return Unmanaged.fromOpaque(opaque)
  }
  @_transparent @_alwaysEmitIntoClient internal static func _encode(_ value: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation._Storage {
    let bits = value.map { Int(bitPattern: $0.toOpaque())} ?? 0
    return _Storage(bits._value)
  }
}
extension Swift.Unmanaged.AtomicOptionalRepresentation : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicLoadOrdering) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicLoad(ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicStore(_ desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicStoreOrdering) {
    _extract(pointer)._atomicStore(_encode(desired), ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicExchange(_ desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value {
    _decode(_extract(pointer)._atomicExchange(_encode(desired), ordering: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      ordering: ordering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, desired: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value, at pointer: Swift.UnsafeMutablePointer<Swift.Unmanaged<Instance>.AtomicOptionalRepresentation>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Swift.Unmanaged<Instance>.AtomicOptionalRepresentation.Value) {
    let (exchanged, original) = _extract(pointer)._atomicWeakCompareExchange(
      expected: _encode(expected),
      desired: _encode(desired),
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
    return (exchanged, _decode(original))
  }
}
@_alwaysEmitIntoClient @_transparent internal func _atomicMemoryFence(ordering: Atomics.AtomicUpdateOrdering) {
  switch ordering {
    case .relaxed:
      break
    case .acquiring:
      Builtin.fence_acquire()
    case .releasing:
      Builtin.fence_release()
    case .acquiringAndReleasing:
      Builtin.fence_acqrel()
    case .sequentiallyConsistent:
      Builtin.fence_seqcst()
    default:
      fatalError("Unsupported ordering")
  }
}
@usableFromInline
@frozen @_alignment(1) internal struct _AtomicInt8Storage {
  @usableFromInline
  internal var _value: Builtin.Int8
  @_alwaysEmitIntoClient @_transparent internal init(_ value: Builtin.Int8) {
    self._value = value
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt8Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt8Storage(Builtin.atomicload_monotonic_Int8(_rawValue))
    case .acquiring:
      return _AtomicInt8Storage(Builtin.atomicload_acquire_Int8(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt8Storage(Builtin.atomicload_seqcst_Int8(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int8(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int8(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int8(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt8Storage, desired: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt8Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt8Storage, desired: Atomics._AtomicInt8Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt8Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt8Storage, desired: Atomics._AtomicInt8Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt8Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt8Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt8Storage(Builtin.atomicload_monotonic_Int8(_rawValue))
    case .acquiring:
      return _AtomicInt8Storage(Builtin.atomicload_acquire_Int8(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt8Storage(Builtin.atomicload_seqcst_Int8(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int8(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int8(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int8(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int8(
        _rawValue, desired._value)
      return _AtomicInt8Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt8Storage, desired: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt8Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt8Storage, desired: Atomics._AtomicInt8Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt8Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt8Storage, desired: Atomics._AtomicInt8Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt8Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int8(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt8Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt8Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt8Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int8(
        _rawValue, operand._value)
      return _AtomicInt8Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#endif
@usableFromInline
@frozen @_alignment(2) internal struct _AtomicInt16Storage {
  @usableFromInline
  internal var _value: Builtin.Int16
  @_alwaysEmitIntoClient @_transparent internal init(_ value: Builtin.Int16) {
    self._value = value
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt16Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt16Storage(Builtin.atomicload_monotonic_Int16(_rawValue))
    case .acquiring:
      return _AtomicInt16Storage(Builtin.atomicload_acquire_Int16(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt16Storage(Builtin.atomicload_seqcst_Int16(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int16(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int16(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int16(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt16Storage, desired: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt16Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt16Storage, desired: Atomics._AtomicInt16Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt16Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt16Storage, desired: Atomics._AtomicInt16Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt16Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt16Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt16Storage(Builtin.atomicload_monotonic_Int16(_rawValue))
    case .acquiring:
      return _AtomicInt16Storage(Builtin.atomicload_acquire_Int16(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt16Storage(Builtin.atomicload_seqcst_Int16(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int16(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int16(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int16(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int16(
        _rawValue, desired._value)
      return _AtomicInt16Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt16Storage, desired: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt16Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt16Storage, desired: Atomics._AtomicInt16Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt16Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt16Storage, desired: Atomics._AtomicInt16Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt16Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int16(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt16Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt16Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt16Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int16(
        _rawValue, operand._value)
      return _AtomicInt16Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#endif
@usableFromInline
@frozen @_alignment(4) internal struct _AtomicInt32Storage {
  @usableFromInline
  internal var _value: Builtin.Int32
  @_alwaysEmitIntoClient @_transparent internal init(_ value: Builtin.Int32) {
    self._value = value
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt32Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt32Storage(Builtin.atomicload_monotonic_Int32(_rawValue))
    case .acquiring:
      return _AtomicInt32Storage(Builtin.atomicload_acquire_Int32(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt32Storage(Builtin.atomicload_seqcst_Int32(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int32(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int32(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int32(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt32Storage, desired: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt32Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt32Storage, desired: Atomics._AtomicInt32Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt32Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt32Storage, desired: Atomics._AtomicInt32Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt32Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt32Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt32Storage(Builtin.atomicload_monotonic_Int32(_rawValue))
    case .acquiring:
      return _AtomicInt32Storage(Builtin.atomicload_acquire_Int32(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt32Storage(Builtin.atomicload_seqcst_Int32(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int32(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int32(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int32(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int32(
        _rawValue, desired._value)
      return _AtomicInt32Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt32Storage, desired: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt32Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt32Storage, desired: Atomics._AtomicInt32Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt32Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt32Storage, desired: Atomics._AtomicInt32Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt32Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int32(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt32Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt32Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt32Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int32(
        _rawValue, operand._value)
      return _AtomicInt32Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#endif
@usableFromInline
@frozen @_alignment(8) internal struct _AtomicInt64Storage {
  @usableFromInline
  internal var _value: Builtin.Int64
  @_alwaysEmitIntoClient @_transparent internal init(_ value: Builtin.Int64) {
    self._value = value
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt64Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt64Storage(Builtin.atomicload_monotonic_Int64(_rawValue))
    case .acquiring:
      return _AtomicInt64Storage(Builtin.atomicload_acquire_Int64(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt64Storage(Builtin.atomicload_seqcst_Int64(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int64(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int64(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int64(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt64Storage, desired: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt64Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt64Storage, desired: Atomics._AtomicInt64Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt64Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt64Storage, desired: Atomics._AtomicInt64Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt64Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt64Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt64Storage(Builtin.atomicload_monotonic_Int64(_rawValue))
    case .acquiring:
      return _AtomicInt64Storage(Builtin.atomicload_acquire_Int64(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt64Storage(Builtin.atomicload_seqcst_Int64(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int64(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int64(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int64(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int64(
        _rawValue, desired._value)
      return _AtomicInt64Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt64Storage, desired: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt64Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt64Storage, desired: Atomics._AtomicInt64Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt64Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt64Storage, desired: Atomics._AtomicInt64Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt64Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int64(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt64Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingIncrement(by operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_add_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_add_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_add_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_add_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_add_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenWrappingDecrement(by operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_sub_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_sub_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_sub_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_sub_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_sub_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseAnd(with operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_and_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_and_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_and_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_and_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_and_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseOr(with operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_or_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_or_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_or_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_or_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_or_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoadThenBitwiseXor(with operand: Atomics._AtomicInt64Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt64Storage {
    switch ordering {
    case .relaxed:
      let value = Builtin.atomicrmw_xor_monotonic_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiring:
      let value = Builtin.atomicrmw_xor_acquire_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .releasing:
      let value = Builtin.atomicrmw_xor_release_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .acquiringAndReleasing:
      let value = Builtin.atomicrmw_xor_acqrel_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    case .sequentiallyConsistent:
      let value = Builtin.atomicrmw_xor_seqcst_Int64(
        _rawValue, operand._value)
      return _AtomicInt64Storage(value)
    default:
      preconditionFailure("Unsupported ordering")
    }
  }
}
#endif
@usableFromInline
@frozen @_alignment(16) internal struct _AtomicInt128Storage {
  @usableFromInline
  internal var _value: Builtin.Int128
  @_alwaysEmitIntoClient @_transparent internal init(_ value: Builtin.Int128) {
    self._value = value
  }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt128Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt128Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt128Storage(Builtin.atomicload_monotonic_Int128(_rawValue))
    case .acquiring:
      return _AtomicInt128Storage(Builtin.atomicload_acquire_Int128(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt128Storage(Builtin.atomicload_seqcst_Int128(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt128Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int128(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int128(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int128(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt128Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt128Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt128Storage, desired: Atomics._AtomicInt128Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt128Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt128Storage, desired: Atomics._AtomicInt128Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt128Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt128Storage, desired: Atomics._AtomicInt128Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt128Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicInt128Storage {
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicLoad(ordering: Atomics.AtomicLoadOrdering) -> Atomics._AtomicInt128Storage {
    switch ordering {
    case .relaxed:
      return _AtomicInt128Storage(Builtin.atomicload_monotonic_Int128(_rawValue))
    case .acquiring:
      return _AtomicInt128Storage(Builtin.atomicload_acquire_Int128(_rawValue))
    case .sequentiallyConsistent:
      return _AtomicInt128Storage(Builtin.atomicload_seqcst_Int128(_rawValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicStore(_ desired: Atomics._AtomicInt128Storage, ordering: Atomics.AtomicStoreOrdering) {
    switch ordering {
    case .relaxed:
      Builtin.atomicstore_monotonic_Int128(_rawValue, desired._value)
    case .releasing:
      Builtin.atomicstore_release_Int128(_rawValue, desired._value)
    case .sequentiallyConsistent:
      Builtin.atomicstore_seqcst_Int128(_rawValue, desired._value)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicExchange(_ desired: Atomics._AtomicInt128Storage, ordering: Atomics.AtomicUpdateOrdering) -> Atomics._AtomicInt128Storage {
    switch ordering {
    case .relaxed:
      let oldValue = Builtin.atomicrmw_xchg_monotonic_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .acquiring:
      let oldValue = Builtin.atomicrmw_xchg_acquire_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .releasing:
      let oldValue = Builtin.atomicrmw_xchg_release_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .acquiringAndReleasing:
      let oldValue = Builtin.atomicrmw_xchg_acqrel_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    case .sequentiallyConsistent:
      let oldValue = Builtin.atomicrmw_xchg_seqcst_Int128(
        _rawValue, desired._value)
      return _AtomicInt128Storage(oldValue)
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt128Storage, desired: Atomics._AtomicInt128Storage, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt128Storage) {
    switch ordering {
    case .relaxed:
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .acquiring:
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .releasing:
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .acquiringAndReleasing:
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case .sequentiallyConsistent:
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    default:
      fatalError("Unsupported ordering")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicCompareExchange(expected: Atomics._AtomicInt128Storage, desired: Atomics._AtomicInt128Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt128Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
  @_semantics("atomics.requires_constant_orderings") @_alwaysEmitIntoClient @_transparent internal func _atomicWeakCompareExchange(expected: Atomics._AtomicInt128Storage, desired: Atomics._AtomicInt128Storage, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Atomics._AtomicInt128Storage) {
     
     
     
    switch (successOrdering, failureOrdering) {
    case (.relaxed, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_monotonic_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.relaxed, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acquire_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acquire_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiring, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_release_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.releasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_acqrel_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.acquiringAndReleasing, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .relaxed):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_monotonic_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .acquiring):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_acquire_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    case (.sequentiallyConsistent, .sequentiallyConsistent):
      let (oldValue, won) = Builtin.cmpxchg_seqcst_seqcst_weak_Int128(
        _rawValue, expected._value, desired._value)
      return (Bool(won), _AtomicInt128Storage(oldValue))
    default:
      preconditionFailure("Unsupported orderings")
    }
  }
}
#endif
@usableFromInline
internal typealias _AtomicIntStorage = Atomics._AtomicInt64Storage
@usableFromInline
internal typealias _AtomicDoubleWordStorage = Atomics._AtomicInt128Storage
public protocol AtomicInteger : Atomics.AtomicValue, Swift.FixedWidthInteger where Self == Self.AtomicRepresentation.Value, Self.AtomicRepresentation : Atomics.AtomicIntegerStorage {
}
public protocol AtomicIntegerStorage : Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenWrappingIncrement(by operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenWrappingDecrement(by operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenBitwiseAnd(with operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenBitwiseOr(with operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoadThenBitwiseXor(with operand: Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> Self.Value
}
public protocol AtomicOptionalWrappable : Atomics.AtomicValue {
  associatedtype AtomicOptionalRepresentation : Atomics.AtomicStorage where Self.AtomicOptionalRepresentation.Value == Self.AtomicRepresentation.Value?
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : Atomics.AtomicValue where Wrapped : Atomics.AtomicOptionalWrappable, Wrapped == Wrapped.AtomicRepresentation.Value {
  public typealias AtomicRepresentation = Wrapped.AtomicOptionalRepresentation
}
#else
extension Swift.Optional : Atomics.AtomicValue where Wrapped : Atomics.AtomicOptionalWrappable, Wrapped == Wrapped.AtomicRepresentation.Value {
  public typealias AtomicRepresentation = Wrapped.AtomicOptionalRepresentation
}
#endif
public protocol AtomicReference : AnyObject, Atomics.AtomicOptionalWrappable {
  associatedtype _AtomicBase : AnyObject = Self where Self.AtomicOptionalRepresentation == Atomics.AtomicOptionalReferenceStorage<Self._AtomicBase>, Self.AtomicRepresentation == Atomics.AtomicReferenceStorage<Self._AtomicBase>
}
@inlinable @inline(__always) internal var _concurrencyWindow: Swift.Int {
  get { 20 }
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicReferenceStorage {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation> {
    get {
    UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: DoubleWord.AtomicRepresentation.self)
  }
  }
}
#else
extension Swift.UnsafeMutablePointer where Pointee == Atomics._AtomicReferenceStorage {
  @inlinable @inline(__always) internal var _extract: Swift.UnsafeMutablePointer<Atomics.DoubleWord.AtomicRepresentation> {
    get {
    UnsafeMutableRawPointer(self)
      .assumingMemoryBound(to: DoubleWord.AtomicRepresentation.self)
  }
  }
}
#endif
@usableFromInline
internal struct _AtomicReferenceStorage {
  @usableFromInline
  internal init(_ value: __owned Swift.AnyObject?)
  @usableFromInline
  internal func dispose() -> Swift.AnyObject?
  @usableFromInline
  internal static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Atomics._AtomicReferenceStorage>) -> Swift.AnyObject?
  @usableFromInline
  internal static func atomicExchange(_ desired: __owned Swift.AnyObject?, at pointer: Swift.UnsafeMutablePointer<Atomics._AtomicReferenceStorage>) -> Swift.AnyObject?
  @usableFromInline
  internal static func atomicCompareExchange(expected: Swift.AnyObject?, desired: __owned Swift.AnyObject?, at pointer: Swift.UnsafeMutablePointer<Atomics._AtomicReferenceStorage>) -> (exchanged: Swift.Bool, original: Swift.AnyObject?)
}
@frozen public struct AtomicReferenceStorage<Value> where Value : AnyObject {
  @usableFromInline
  internal var _storage: Atomics._AtomicReferenceStorage
  @inlinable public init(_ value: __owned Value) {
    _storage = .init(value)
  }
  @inlinable public func dispose() -> Value {
    return unsafeDowncast(_storage.dispose()!, to: Value.self)
  }
}
extension Atomics.AtomicReferenceStorage {
  @inlinable @inline(__always) @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Atomics.AtomicReferenceStorage<Value>>) -> Swift.UnsafeMutablePointer<Atomics._AtomicReferenceStorage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _AtomicReferenceStorage.self)
  }
}
extension Atomics.AtomicReferenceStorage : Atomics.AtomicStorage {
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicReferenceStorage<Value>>, ordering: Atomics.AtomicLoadOrdering) -> Value {
     
    let result = _AtomicReferenceStorage.atomicLoad(at: Self._extract(pointer))
    return unsafeDowncast(result!, to: Value.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicStore(_ desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicReferenceStorage<Value>>, ordering: Atomics.AtomicStoreOrdering) {
     
    _ = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicExchange(_ desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicReferenceStorage<Value>>, ordering: Atomics.AtomicUpdateOrdering) -> Value {
     
    let result = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
    return unsafeDowncast(result!, to: Value.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Value, desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicReferenceStorage<Value>>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
     
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    return (result.exchanged, unsafeDowncast(result.original!, to: Value.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Value, desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicReferenceStorage<Value>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
     
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    return (result.exchanged, unsafeDowncast(result.original!, to: Value.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicWeakCompareExchange(expected: Value, desired: __owned Value, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicReferenceStorage<Value>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
     
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    return (result.exchanged, unsafeDowncast(result.original!, to: Value.self))
  }
}
@frozen public struct AtomicOptionalReferenceStorage<Instance> where Instance : AnyObject {
  @usableFromInline
  internal var _storage: Atomics._AtomicReferenceStorage
  @inlinable public init(_ value: __owned Instance?) {
    _storage = .init(value)
  }
  @inlinable public func dispose() -> Instance? {
    guard let value = _storage.dispose() else { return nil }
    return unsafeDowncast(value, to: Instance.self)
  }
}
extension Atomics.AtomicOptionalReferenceStorage {
  @inlinable @inline(__always) @_alwaysEmitIntoClient internal static func _extract(_ ptr: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalReferenceStorage<Instance>>) -> Swift.UnsafeMutablePointer<Atomics._AtomicReferenceStorage> {
     
    return UnsafeMutableRawPointer(ptr)
      .assumingMemoryBound(to: _AtomicReferenceStorage.self)
  }
}
extension Atomics.AtomicOptionalReferenceStorage : Atomics.AtomicStorage {
  public typealias Value = Instance?
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalReferenceStorage<Instance>>, ordering: Atomics.AtomicLoadOrdering) -> Instance? {
     
    let result = _AtomicReferenceStorage.atomicLoad(at: Self._extract(pointer))
    guard let r = result else { return nil }
    return unsafeDowncast(r, to: Instance.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicStore(_ desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalReferenceStorage<Instance>>, ordering: Atomics.AtomicStoreOrdering) {
     
    _ = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicExchange(_ desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalReferenceStorage<Instance>>, ordering: Atomics.AtomicUpdateOrdering) -> Instance? {
     
    let result = _AtomicReferenceStorage.atomicExchange(
      desired,
      at: _extract(pointer))
    guard let r = result else { return nil }
    return unsafeDowncast(r, to: Instance.self)
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Instance?, desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalReferenceStorage<Instance>>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Instance?) {
     
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    guard let original = result.original else { return (result.exchanged, nil) }
    return (result.exchanged, unsafeDowncast(original, to: Instance.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicCompareExchange(expected: Instance?, desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalReferenceStorage<Instance>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Instance?) {
     
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    guard let original = result.original else { return (result.exchanged, nil) }
    return (result.exchanged, unsafeDowncast(original, to: Instance.self))
  }
  @inlinable @inline(__always) @_alwaysEmitIntoClient @_semantics("atomics.requires_constant_orderings") public static func atomicWeakCompareExchange(expected: Instance?, desired: __owned Instance?, at pointer: Swift.UnsafeMutablePointer<Atomics.AtomicOptionalReferenceStorage<Instance>>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Instance?) {
     
    let result = _AtomicReferenceStorage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _extract(pointer))
    guard let original = result.original else { return (result.exchanged, nil) }
    return (result.exchanged, unsafeDowncast(original, to: Instance.self))
  }
}
public protocol AtomicStorage {
  associatedtype Value
  init(_ value: __owned Self.Value)
  __consuming func dispose() -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicLoad(at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicLoadOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicStore(_ desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicStoreOrdering)
  @_semantics("atomics.requires_constant_orderings") static func atomicExchange(_ desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> Self.Value
  @_semantics("atomics.requires_constant_orderings") static func atomicCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Self.Value)
  @_semantics("atomics.requires_constant_orderings") static func atomicCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Self.Value)
  @_semantics("atomics.requires_constant_orderings") static func atomicWeakCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Self.Value)
  @_semantics("atomics.requires_constant_orderings") static func atomicWeakCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Self.Value)
}
extension Atomics.AtomicStorage {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Self.Value) {
    atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: pointer,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering))
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public static func atomicWeakCompareExchange(expected: Self.Value, desired: __owned Self.Value, at pointer: Swift.UnsafeMutablePointer<Self>, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Self.Value) {
    atomicWeakCompareExchange(
      expected: expected,
      desired: desired,
      at: pointer,
      successOrdering: ordering,
      failureOrdering: ._failureOrdering(for: ordering))
  }
}
public protocol AtomicValue {
  associatedtype AtomicRepresentation : Atomics.AtomicStorage
}
@frozen public struct AtomicLoadOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @_semantics("constant_evaluable") @inlinable @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
extension Atomics.AtomicLoadOrdering {
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: Atomics.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiring: Atomics.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 2)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: Atomics.AtomicLoadOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
extension Atomics.AtomicLoadOrdering : Swift.Equatable {
  @_transparent public static func == (left: Atomics.AtomicLoadOrdering, right: Atomics.AtomicLoadOrdering) -> Swift.Bool {
    return left._rawValue == right._rawValue
  }
}
extension Atomics.AtomicLoadOrdering : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Atomics.AtomicLoadOrdering : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@frozen public struct AtomicStoreOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @_semantics("constant_evaluable") @inlinable @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
extension Atomics.AtomicStoreOrdering {
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: Atomics.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var releasing: Atomics.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 3)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: Atomics.AtomicStoreOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
extension Atomics.AtomicStoreOrdering : Swift.Equatable {
  @_transparent public static func == (left: Atomics.AtomicStoreOrdering, right: Atomics.AtomicStoreOrdering) -> Swift.Bool {
    return left._rawValue == right._rawValue
  }
}
extension Atomics.AtomicStoreOrdering : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Atomics.AtomicStoreOrdering : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@frozen public struct AtomicUpdateOrdering {
  @usableFromInline
  internal var _rawValue: Swift.Int
  @_semantics("constant_evaluable") @inlinable @_transparent internal init(_rawValue: Swift.Int) {
    self._rawValue = _rawValue
  }
}
extension Atomics.AtomicUpdateOrdering {
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var relaxed: Atomics.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 0)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiring: Atomics.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 2)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var releasing: Atomics.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 3)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var acquiringAndReleasing: Atomics.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 4)
  }
  }
  @_semantics("constant_evaluable") @_alwaysEmitIntoClient @_transparent public static var sequentiallyConsistent: Atomics.AtomicUpdateOrdering {
    @_transparent get {
    Self(_rawValue: 5)
  }
  }
}
extension Atomics.AtomicUpdateOrdering : Swift.Equatable {
  @_transparent public static func == (left: Atomics.AtomicUpdateOrdering, right: Atomics.AtomicUpdateOrdering) -> Swift.Bool {
    return left._rawValue == right._rawValue
  }
}
extension Atomics.AtomicUpdateOrdering : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(_rawValue)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Atomics.AtomicUpdateOrdering : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Atomics.AtomicLoadOrdering {
  @_semantics("constant_evaluable") @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient internal static func _failureOrdering(for ordering: Atomics.AtomicUpdateOrdering) -> Atomics.AtomicLoadOrdering {
    switch ordering {
    case .relaxed: return .relaxed
    case .acquiring: return .acquiring
    case .releasing: return .relaxed
    case .acquiringAndReleasing: return .acquiring
    case .sequentiallyConsistent: return .sequentiallyConsistent
    default: fatalError("Unsupported ordering")
    }
  }
}
@_semantics("atomics.requires_constant_orderings") @_transparent public func atomicMemoryFence(ordering: Atomics.AtomicUpdateOrdering) {
  _atomicMemoryFence(ordering: ordering)
}
@frozen @_alignment(16) public struct DoubleWord {
  @usableFromInline
  internal typealias _Builtin = Builtin.Int128
  public var first: Swift.UInt
  public var second: Swift.UInt
  @inlinable @inline(__always) public init(first: Swift.UInt, second: Swift.UInt) {
    self.first = first
    self.second = second
  }
}
extension Atomics.DoubleWord {
  @_alwaysEmitIntoClient @_transparent internal init(_ builtin: Atomics.DoubleWord._Builtin) {
    self = unsafeBitCast(builtin, to: DoubleWord.self)
  }
  @_alwaysEmitIntoClient @_transparent internal var _value: Atomics.DoubleWord._Builtin {
    @_transparent get {
    unsafeBitCast(self, to: _Builtin.self)
  }
  }
}
extension Atomics.DoubleWord {
  @available(*, deprecated, renamed: "init(first:second:)")
  @inlinable @inline(__always) public init(high: Swift.UInt, low: Swift.UInt) {
    self.init(first: low, second: high)
  }
  @available(*, deprecated, renamed: "second")
  @inlinable @inline(__always) public var high: Swift.UInt {
    get { second }
    set { second = newValue }
  }
  @available(*, deprecated, renamed: "first")
  @inlinable @inline(__always) public var low: Swift.UInt {
    get { first }
    set { first = newValue }
  }
}
extension Atomics.DoubleWord : Swift.Equatable {
  @inlinable public static func == (left: Atomics.DoubleWord, right: Atomics.DoubleWord) -> Swift.Bool {
    left.first == right.first && left.second == right.second
  }
}
extension Atomics.DoubleWord : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(self.first)
    hasher.combine(self.second)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension Atomics.DoubleWord : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_fixed_layout public class ManagedAtomic<Value> where Value : Atomics.AtomicValue, Value == Value.AtomicRepresentation.Value {
  @usableFromInline
  internal typealias _Storage = Value.AtomicRepresentation
  @usableFromInline
  internal var __storage: Atomics.ManagedAtomic<Value>._Storage
  @inline(__always) @_alwaysEmitIntoClient public init(_ value: Value) {
    __storage = _Storage(value)
  }
  @objc deinit
  @_alwaysEmitIntoClient @inline(__always) internal var _ptr: Swift.UnsafeMutablePointer<Atomics.ManagedAtomic<Value>._Storage> {
    get {
    _getUnsafePointerToStoredProperties(self)
      .assumingMemoryBound(to: _Storage.self)
  }
  }
}
extension Atomics.ManagedAtomic : @unchecked Swift.Sendable where Value : Swift.Sendable {
}
extension Atomics.ManagedAtomic {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func load(ordering: Atomics.AtomicLoadOrdering) -> Value {
    _Storage.atomicLoad(at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func store(_ desired: __owned Value, ordering: Atomics.AtomicStoreOrdering) {
    _Storage.atomicStore(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func exchange(_ desired: __owned Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicExchange(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func weakCompareExchange(expected: Value, desired: __owned Value, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicWeakCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func weakCompareExchange(expected: Value, desired: __owned Value, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicWeakCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
}
@_fixed_layout public class ManagedAtomicLazyReference<Instance> where Instance : AnyObject {
  public typealias Value = Instance?
  @usableFromInline
  internal typealias _Rep = Swift.Optional<Swift.Unmanaged<Instance>>.AtomicRepresentation
  @usableFromInline
  final internal let _storage: Atomics.ManagedAtomicLazyReference<Instance>._Rep
  @inlinable public init() {
    _storage = _Rep(nil)
  }
  @objc deinit
  @_alwaysEmitIntoClient @inline(__always) internal var _ptr: Swift.UnsafeMutablePointer<Atomics.ManagedAtomicLazyReference<Instance>._Rep> {
    get {
    _getUnsafePointerToStoredProperties(self).assumingMemoryBound(to: _Rep.self)
  }
  }
}
extension Atomics.ManagedAtomicLazyReference : @unchecked Swift.Sendable where Instance : Swift.Sendable {
}
extension Atomics.ManagedAtomicLazyReference {
  public func storeIfNilThenLoad(_ desired: __owned Instance) -> Instance
  public func load() -> Instance?
}
@frozen public struct UnsafeAtomic<Value> where Value : Atomics.AtomicValue, Value == Value.AtomicRepresentation.Value {
  public typealias Storage = Value.AtomicRepresentation
  @usableFromInline
  internal typealias _Storage = Atomics.UnsafeAtomic<Value>.Storage
  @usableFromInline
  internal let _ptr: Swift.UnsafeMutablePointer<Atomics.UnsafeAtomic<Value>.Storage>
  @_transparent public init(@_nonEphemeral at pointer: Swift.UnsafeMutablePointer<Atomics.UnsafeAtomic<Value>.Storage>) {
    self._ptr = pointer
  }
  @inlinable public static func create(_ initialValue: __owned Value) -> Atomics.UnsafeAtomic<Value> {
    let ptr = UnsafeMutablePointer<Storage>.allocate(capacity: 1)
    ptr.initialize(to: Storage(initialValue))
    return Self(at: ptr)
  }
  @discardableResult
  @inlinable public func destroy() -> Value {
    let result = _ptr.pointee.dispose()
    _ptr.deinitialize(count: 1)
    _ptr.deallocate()
    return result
  }
}
extension Atomics.UnsafeAtomic : @unchecked Swift.Sendable where Value : Swift.Sendable {
}
extension Atomics.UnsafeAtomic {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func load(ordering: Atomics.AtomicLoadOrdering) -> Value {
    _Storage.atomicLoad(at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func store(_ desired: __owned Value, ordering: Atomics.AtomicStoreOrdering) {
    _Storage.atomicStore(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func exchange(_ desired: __owned Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicExchange(desired, at: _ptr, ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func compareExchange(expected: Value, desired: __owned Value, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func weakCompareExchange(expected: Value, desired: __owned Value, ordering: Atomics.AtomicUpdateOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicWeakCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func weakCompareExchange(expected: Value, desired: __owned Value, successOrdering: Atomics.AtomicUpdateOrdering, failureOrdering: Atomics.AtomicLoadOrdering) -> (exchanged: Swift.Bool, original: Value) {
    _Storage.atomicWeakCompareExchange(
      expected: expected,
      desired: desired,
      at: _ptr,
      successOrdering: successOrdering,
      failureOrdering: failureOrdering)
  }
}
@frozen public struct UnsafeAtomicLazyReference<Instance> where Instance : AnyObject {
  public typealias Value = Instance?
  @usableFromInline
  internal typealias _Rep = Swift.Optional<Swift.Unmanaged<Instance>>.AtomicRepresentation
  @usableFromInline
  internal let _ptr: Swift.UnsafeMutablePointer<Atomics.UnsafeAtomicLazyReference<Instance>._Rep>
  @_transparent public init(@_nonEphemeral at pointer: Swift.UnsafeMutablePointer<Atomics.UnsafeAtomicLazyReference<Instance>.Storage>) {
     
    _ptr = UnsafeMutableRawPointer(pointer).assumingMemoryBound(to: _Rep.self)
  }
}
extension Atomics.UnsafeAtomicLazyReference : @unchecked Swift.Sendable where Instance : Swift.Sendable {
}
extension Atomics.UnsafeAtomicLazyReference {
  @frozen public struct Storage {
    @usableFromInline
    internal var _storage: Atomics.UnsafeAtomicLazyReference<Instance>._Rep
    @inlinable @inline(__always) public init() {
      _storage = _Rep(nil)
    }
    @discardableResult
    @inlinable @inline(__always) public mutating func dispose() -> Atomics.UnsafeAtomicLazyReference<Instance>.Value {
      defer { _storage = _Rep(nil) }
      return _storage.dispose()?.takeRetainedValue()
    }
  }
}
extension Atomics.UnsafeAtomicLazyReference {
  @inlinable public static func create() -> Atomics.UnsafeAtomicLazyReference<Instance> {
    let ptr = UnsafeMutablePointer<Storage>.allocate(capacity: 1)
    ptr.initialize(to: Storage())
    return Self(at: ptr)
  }
  @discardableResult
  @inlinable public func destroy() -> Atomics.UnsafeAtomicLazyReference<Instance>.Value {
     
    let address = UnsafeMutableRawPointer(_ptr)
      .assumingMemoryBound(to: Storage.self)
    defer { address.deallocate() }
    return address.pointee.dispose()
  }
}
extension Atomics.UnsafeAtomicLazyReference {
  public func storeIfNilThenLoad(_ desired: __owned Instance) -> Instance
  public func load() -> Instance?
}
extension Atomics.UnsafeAtomic where Value : Atomics.AtomicInteger {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingIncrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingDecrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseAnd(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseOr(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseXor(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrementThenLoad(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &+ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrementThenLoad(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &- operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseAndThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original & operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseOrThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original | operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseXorThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original ^ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) {
    _ = _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) {
    _ = _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
}
extension Atomics.ManagedAtomic where Value : Atomics.AtomicInteger {
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingIncrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenWrappingDecrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseAnd(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseOr(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func loadThenBitwiseXor(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    _Storage.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrementThenLoad(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &+ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrementThenLoad(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
    return original &- operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseAndThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenBitwiseAnd(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original & operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseOrThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenBitwiseOr(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original | operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func bitwiseXorThenLoad(with operand: Value, ordering: Atomics.AtomicUpdateOrdering) -> Value {
    let original = _Storage.atomicLoadThenBitwiseXor(
      with: operand,
      at: _ptr,
      ordering: ordering)
    return original ^ operand
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingIncrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) {
    _ = _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
  @_semantics("atomics.requires_constant_orderings") @_transparent @_alwaysEmitIntoClient public func wrappingDecrement(by operand: Value = 1, ordering: Atomics.AtomicUpdateOrdering) {
    _ = _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
}
extension Swift.Bool.AtomicRepresentation : Swift.Sendable {}
extension Swift.Bool.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Atomics._AtomicInt8Storage : Swift.Sendable {}
extension Atomics._AtomicInt8Storage : Swift.BitwiseCopyable {}
extension Swift.Int8.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int8.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.Int16.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int16.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.Int32.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int32.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.Int64.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int64.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UInt8.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt8.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UInt16.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt16.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UInt32.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt32.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UInt64.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt64.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.Int.AtomicRepresentation : Swift.Sendable {}
extension Swift.Int.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UInt.AtomicRepresentation : Swift.Sendable {}
extension Swift.UInt.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Atomics.DoubleWord : Swift.Sendable {}
extension Atomics.DoubleWord : Swift.BitwiseCopyable {}
extension Atomics.DoubleWord.AtomicRepresentation : Swift.Sendable {}
extension Atomics.DoubleWord.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UnsafeRawPointer.AtomicRepresentation : Swift.Sendable {}
extension Swift.UnsafeRawPointer.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation : Swift.Sendable {}
extension Swift.UnsafeMutableRawPointer.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.Unmanaged.AtomicRepresentation : Swift.Sendable {}
extension Swift.Unmanaged.AtomicRepresentation : Swift.BitwiseCopyable {}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation : Swift.Sendable {}
extension Swift.UnsafeRawPointer.AtomicOptionalRepresentation : Swift.BitwiseCopyable {}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation : Swift.Sendable {}
extension Swift.UnsafeMutableRawPointer.AtomicOptionalRepresentation : Swift.BitwiseCopyable {}
extension Swift.Unmanaged.AtomicOptionalRepresentation : Swift.Sendable {}
extension Swift.Unmanaged.AtomicOptionalRepresentation : Swift.BitwiseCopyable {}
extension Atomics._AtomicInt16Storage : Swift.Sendable {}
extension Atomics._AtomicInt16Storage : Swift.BitwiseCopyable {}
extension Atomics._AtomicInt32Storage : Swift.Sendable {}
extension Atomics._AtomicInt32Storage : Swift.BitwiseCopyable {}
extension Atomics._AtomicInt64Storage : Swift.Sendable {}
extension Atomics._AtomicInt64Storage : Swift.BitwiseCopyable {}
extension Atomics._AtomicInt128Storage : Swift.Sendable {}
extension Atomics._AtomicInt128Storage : Swift.BitwiseCopyable {}
extension Atomics.AtomicLoadOrdering : Swift.Sendable {}
extension Atomics.AtomicLoadOrdering : Swift.BitwiseCopyable {}
extension Atomics.AtomicStoreOrdering : Swift.Sendable {}
extension Atomics.AtomicStoreOrdering : Swift.BitwiseCopyable {}
extension Atomics.AtomicUpdateOrdering : Swift.Sendable {}
extension Atomics.AtomicUpdateOrdering : Swift.BitwiseCopyable {}
extension Atomics.UnsafeAtomic : Swift.BitwiseCopyable {}
extension Atomics.UnsafeAtomicLazyReference : Swift.BitwiseCopyable {}
extension Atomics.UnsafeAtomicLazyReference.Storage : Swift.Sendable {}
extension Atomics.UnsafeAtomicLazyReference.Storage : Swift.BitwiseCopyable {}
