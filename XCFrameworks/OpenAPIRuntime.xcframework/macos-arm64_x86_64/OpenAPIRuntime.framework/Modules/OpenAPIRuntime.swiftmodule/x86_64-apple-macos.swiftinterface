// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target x86_64-apple-macos10.15 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-upcoming-feature ExistentialAny -enable-upcoming-feature MemberImportVisibility -enable-bare-slash-regex -module-name OpenAPIRuntime -package-name swift_openapi_runtime
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import CoreFoundation
import Foundation
import Foundation/*.Data*/
import Foundation/*.JSONDecoder*/
import Foundation/*.JSONEncoder*/
import Foundation/*.LocalizedError*/
import Foundation/*.NSLock*/
import Foundation/*.NSNull*/
import Foundation/*.NSNumber*/
import Foundation/*.URL*/
import Foundation/*.URLComponents*/
import HTTPTypes
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public protocol AcceptableProtocol : Swift.CaseIterable, Swift.Hashable, Swift.RawRepresentable, Swift.Sendable where Self.RawValue == Swift.String {
}
public struct QualityValue : Swift.Sendable, Swift.Hashable {
  public var isDefault: Swift.Bool {
    get
  }
  public init(doubleValue: Swift.Double)
  public var doubleValue: Swift.Double {
    get
  }
}
extension OpenAPIRuntime.QualityValue : Swift.RawRepresentable {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension OpenAPIRuntime.QualityValue : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.UInt16)
  public typealias IntegerLiteralType = Swift.UInt16
}
extension OpenAPIRuntime.QualityValue : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension Swift.Array {
  public static func defaultValues<T>() -> [OpenAPIRuntime.AcceptHeaderContentType<T>] where Element == OpenAPIRuntime.AcceptHeaderContentType<T>, T : OpenAPIRuntime.AcceptableProtocol
}
public struct AcceptHeaderContentType<ContentType> : Swift.Sendable, Swift.Hashable where ContentType : OpenAPIRuntime.AcceptableProtocol {
  public var contentType: ContentType
  public var quality: OpenAPIRuntime.QualityValue
  public init(contentType: ContentType, quality: OpenAPIRuntime.QualityValue = 1.0)
  public static var defaultValues: [OpenAPIRuntime.AcceptHeaderContentType<ContentType>] {
    get
  }
}
extension OpenAPIRuntime.AcceptHeaderContentType : Swift.RawRepresentable {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension Swift.Array {
  public func sortedByQuality<T>() -> [OpenAPIRuntime.AcceptHeaderContentType<T>] where Element == OpenAPIRuntime.AcceptHeaderContentType<T>, T : OpenAPIRuntime.AcceptableProtocol
}
public struct Base64EncodedData : Swift.Sendable, Swift.Hashable {
  public var data: Swift.ArraySlice<Swift.UInt8>
  public init(_ data: Swift.ArraySlice<Swift.UInt8>)
  public init(_ data: some Sequence<UInt8>)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.Base64EncodedData, b: OpenAPIRuntime.Base64EncodedData) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension OpenAPIRuntime.Base64EncodedData : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Swift.UInt8...)
  public typealias ArrayLiteralElement = Swift.UInt8
}
extension OpenAPIRuntime.Base64EncodedData : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct OpenAPIValueContainer : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var value: (any Swift.Sendable)?
  public init(unvalidatedValue: (any Swift.Sendable)? = nil) throws
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (lhs: OpenAPIRuntime.OpenAPIValueContainer, rhs: OpenAPIRuntime.OpenAPIValueContainer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension OpenAPIRuntime.OpenAPIValueContainer : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension OpenAPIRuntime.OpenAPIValueContainer : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension OpenAPIRuntime.OpenAPIValueContainer : Swift.ExpressibleByNilLiteral {
  public init(nilLiteral: ())
}
extension OpenAPIRuntime.OpenAPIValueContainer : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension OpenAPIRuntime.OpenAPIValueContainer : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
public struct OpenAPIObjectContainer : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var value: [Swift.String : (any Swift.Sendable)?]
  public init()
  public init(unvalidatedValue: [Swift.String : (any Swift.Sendable)?]) throws
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (lhs: OpenAPIRuntime.OpenAPIObjectContainer, rhs: OpenAPIRuntime.OpenAPIObjectContainer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct OpenAPIArrayContainer : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public var value: [(any Swift.Sendable)?]
  public init()
  public init(unvalidatedValue: [(any Swift.Sendable)?]) throws
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (lhs: OpenAPIRuntime.OpenAPIArrayContainer, rhs: OpenAPIRuntime.OpenAPIArrayContainer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct UndocumentedPayload : Swift.Sendable, Swift.Hashable {
  public var headerFields: HTTPTypes.HTTPFields
  public var body: OpenAPIRuntime.HTTPBody?
  public init(headerFields: HTTPTypes.HTTPFields = [:], body: OpenAPIRuntime.HTTPBody? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.UndocumentedPayload, b: OpenAPIRuntime.UndocumentedPayload) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DateTranscoder : Swift.Sendable {
  func encode(_: Foundation.Date) throws -> Swift.String
  func decode(_: Swift.String) throws -> Foundation.Date
}
public struct ISO8601DateTranscoder : OpenAPIRuntime.DateTranscoder, @unchecked Swift.Sendable {
  public init(options: Foundation.ISO8601DateFormatter.Options? = nil)
  public func encode(_ date: Foundation.Date) throws -> Swift.String
  public func decode(_ dateString: Swift.String) throws -> Foundation.Date
}
extension OpenAPIRuntime.DateTranscoder where Self == OpenAPIRuntime.ISO8601DateTranscoder {
  public static var iso8601: OpenAPIRuntime.ISO8601DateTranscoder {
    get
  }
  public static var iso8601WithFractionalSeconds: OpenAPIRuntime.ISO8601DateTranscoder {
    get
  }
}
public protocol CustomCoder : Swift.Sendable {
  func customEncode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  func customDecode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
}
public struct JSONEncodingOptions : Swift.OptionSet, Swift.Sendable {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let prettyPrinted: OpenAPIRuntime.JSONEncodingOptions
  public static let sortedKeys: OpenAPIRuntime.JSONEncodingOptions
  public static let withoutEscapingSlashes: OpenAPIRuntime.JSONEncodingOptions
  public typealias ArrayLiteralElement = OpenAPIRuntime.JSONEncodingOptions
  public typealias Element = OpenAPIRuntime.JSONEncodingOptions
  public typealias RawValue = Swift.UInt
}
public struct Configuration : Swift.Sendable {
  public var dateTranscoder: any OpenAPIRuntime.DateTranscoder
  public var jsonEncodingOptions: OpenAPIRuntime.JSONEncodingOptions
  public var multipartBoundaryGenerator: any OpenAPIRuntime.MultipartBoundaryGenerator
  public var xmlCoder: (any OpenAPIRuntime.CustomCoder)?
  public init(dateTranscoder: any OpenAPIRuntime.DateTranscoder = .iso8601, jsonEncodingOptions: OpenAPIRuntime.JSONEncodingOptions = [.sortedKeys, .prettyPrinted], multipartBoundaryGenerator: any OpenAPIRuntime.MultipartBoundaryGenerator = .random, xmlCoder: (any OpenAPIRuntime.CustomCoder)? = nil)
}
extension Foundation.URL {
  public static let defaultOpenAPIServerURL: Foundation.URL
  public init(validatingOpenAPIServerURL string: Swift.String) throws
}
extension OpenAPIRuntime.UndocumentedPayload {
  @available(*, deprecated, renamed: "init(headerFields:body:)")
  @_disfavoredOverload public init()
}
extension OpenAPIRuntime.Configuration {
  @available(*, deprecated, renamed: "init(dateTranscoder:multipartBoundaryGenerator:xmlCoder:)")
  @_disfavoredOverload public init(dateTranscoder: any OpenAPIRuntime.DateTranscoder = .iso8601, multipartBoundaryGenerator: any OpenAPIRuntime.MultipartBoundaryGenerator = .random)
  @available(*, deprecated, renamed: "init(dateTranscoder:jsonEncodingOptions:multipartBoundaryGenerator:xmlCoder:)")
  @_disfavoredOverload public init(dateTranscoder: any OpenAPIRuntime.DateTranscoder = .iso8601, multipartBoundaryGenerator: any OpenAPIRuntime.MultipartBoundaryGenerator = .random, xmlCoder: (any OpenAPIRuntime.CustomCoder)? = nil)
}
extension _Concurrency.AsyncSequence where Self : Swift.Sendable, Self.Element == Swift.ArraySlice<Swift.UInt8> {
  @available(*, deprecated, renamed: "asDecodedServerSentEvents(while:)")
  @_disfavoredOverload public func asDecodedServerSentEvents() -> OpenAPIRuntime.ServerSentEventsDeserializationSequence<OpenAPIRuntime.ServerSentEventsLineDeserializationSequence<Self>>
  @available(*, deprecated, renamed: "asDecodedServerSentEventsWithJSONData(of:decoder:while:)")
  @_disfavoredOverload public func asDecodedServerSentEventsWithJSONData<JSONDataType>(of dataType: JSONDataType.Type = JSONDataType.self, decoder: Foundation.JSONDecoder = .init()) -> _Concurrency.AsyncThrowingMapSequence<OpenAPIRuntime.ServerSentEventsDeserializationSequence<OpenAPIRuntime.ServerSentEventsLineDeserializationSequence<Self>>, OpenAPIRuntime.ServerSentEventWithJSONData<JSONDataType>> where JSONDataType : Swift.Decodable, JSONDataType : Swift.Hashable, JSONDataType : Swift.Sendable
}
extension OpenAPIRuntime.ServerSentEventsDeserializationSequence {
  @available(*, deprecated, renamed: "init(upstream:while:)")
  @_disfavoredOverload public init(upstream: Upstream)
}
public struct ClientError : Swift.Error {
  public var operationID: Swift.String
  public var operationInput: any Swift.Sendable
  public var request: HTTPTypes.HTTPRequest?
  public var requestBody: OpenAPIRuntime.HTTPBody?
  public var baseURL: Foundation.URL?
  public var response: HTTPTypes.HTTPResponse?
  public var responseBody: OpenAPIRuntime.HTTPBody?
  public var causeDescription: Swift.String
  public var underlyingError: any Swift.Error
  public init(operationID: Swift.String, operationInput: any Swift.Sendable, request: HTTPTypes.HTTPRequest? = nil, requestBody: OpenAPIRuntime.HTTPBody? = nil, baseURL: Foundation.URL? = nil, response: HTTPTypes.HTTPResponse? = nil, responseBody: OpenAPIRuntime.HTTPBody? = nil, causeDescription: Swift.String, underlyingError: any Swift.Error)
}
extension OpenAPIRuntime.ClientError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension OpenAPIRuntime.ClientError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct ServerError : Swift.Error {
  public var operationID: Swift.String
  public var request: HTTPTypes.HTTPRequest
  public var requestBody: OpenAPIRuntime.HTTPBody?
  public var requestMetadata: OpenAPIRuntime.ServerRequestMetadata
  public var operationInput: (any Swift.Sendable)?
  public var operationOutput: (any Swift.Sendable)?
  public var causeDescription: Swift.String
  public var underlyingError: any Swift.Error
  public init(operationID: Swift.String, request: HTTPTypes.HTTPRequest, requestBody: OpenAPIRuntime.HTTPBody?, requestMetadata: OpenAPIRuntime.ServerRequestMetadata, operationInput: (any Swift.Sendable)? = nil, operationOutput: (any Swift.Sendable)? = nil, causeDescription: Swift.String, underlyingError: any Swift.Error)
}
extension OpenAPIRuntime.ServerError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension OpenAPIRuntime.ServerError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct JSONLinesDeserializationSequence<Upstream> : Swift.Sendable where Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence, Upstream.Element == Swift.ArraySlice<Swift.UInt8> {
  public init(upstream: Upstream)
}
extension OpenAPIRuntime.JSONLinesDeserializationSequence : _Concurrency.AsyncSequence {
  public typealias Element = Swift.ArraySlice<Swift.UInt8>
  public struct Iterator<UpstreamIterator> : _Concurrency.AsyncIteratorProtocol where UpstreamIterator : _Concurrency.AsyncIteratorProtocol, UpstreamIterator.Element == Swift.ArraySlice<Swift.UInt8> {
    public mutating func next() async throws -> Swift.ArraySlice<Swift.UInt8>?
    public typealias Element = Swift.ArraySlice<Swift.UInt8>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> OpenAPIRuntime.JSONLinesDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  public typealias AsyncIterator = OpenAPIRuntime.JSONLinesDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension _Concurrency.AsyncSequence where Self.Element == Swift.ArraySlice<Swift.UInt8> {
  public func asDecodedJSONLines<Event>(of eventType: Event.Type = Event.self, decoder: Foundation.JSONDecoder = .init()) -> _Concurrency.AsyncThrowingMapSequence<OpenAPIRuntime.JSONLinesDeserializationSequence<Self>, Event> where Self : Swift.Sendable, Event : Swift.Decodable
}
public struct JSONLinesSerializationSequence<Upstream> : Swift.Sendable where Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence, Upstream.Element == Swift.ArraySlice<Swift.UInt8> {
  public init(upstream: Upstream)
}
extension OpenAPIRuntime.JSONLinesSerializationSequence : _Concurrency.AsyncSequence {
  public typealias Element = Swift.ArraySlice<Swift.UInt8>
  public struct Iterator<UpstreamIterator> : _Concurrency.AsyncIteratorProtocol where UpstreamIterator : _Concurrency.AsyncIteratorProtocol, UpstreamIterator.Element == Swift.ArraySlice<Swift.UInt8> {
    public mutating func next() async throws -> Swift.ArraySlice<Swift.UInt8>?
    public typealias Element = Swift.ArraySlice<Swift.UInt8>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> OpenAPIRuntime.JSONLinesSerializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  public typealias AsyncIterator = OpenAPIRuntime.JSONLinesSerializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension _Concurrency.AsyncSequence where Self : Swift.Sendable, Self.Element : Swift.Encodable, Self.Element : Swift.Sendable {
  public func asEncodedJSONLines(encoder: Foundation.JSONEncoder = {
            let encoder = JSONEncoder()
            encoder.outputFormatting = [.sortedKeys, .withoutEscapingSlashes]
            return encoder
        }()) -> OpenAPIRuntime.JSONLinesSerializationSequence<_Concurrency.AsyncThrowingMapSequence<Self, Swift.ArraySlice<Swift.UInt8>>>
}
public struct JSONSequenceDeserializationSequence<Upstream> : Swift.Sendable where Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence, Upstream.Element == Swift.ArraySlice<Swift.UInt8> {
  public init(upstream: Upstream)
}
extension OpenAPIRuntime.JSONSequenceDeserializationSequence : _Concurrency.AsyncSequence {
  public typealias Element = Swift.ArraySlice<Swift.UInt8>
  public struct Iterator<UpstreamIterator> : _Concurrency.AsyncIteratorProtocol where UpstreamIterator : _Concurrency.AsyncIteratorProtocol, UpstreamIterator.Element == Swift.ArraySlice<Swift.UInt8> {
    public mutating func next() async throws -> Swift.ArraySlice<Swift.UInt8>?
    public typealias Element = Swift.ArraySlice<Swift.UInt8>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> OpenAPIRuntime.JSONSequenceDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  public typealias AsyncIterator = OpenAPIRuntime.JSONSequenceDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension _Concurrency.AsyncSequence where Self.Element == Swift.ArraySlice<Swift.UInt8> {
  public func asDecodedJSONSequence<Event>(of eventType: Event.Type = Event.self, decoder: Foundation.JSONDecoder = .init()) -> _Concurrency.AsyncThrowingMapSequence<OpenAPIRuntime.JSONSequenceDeserializationSequence<Self>, Event> where Self : Swift.Sendable, Event : Swift.Decodable
}
public struct JSONSequenceSerializationSequence<Upstream> : Swift.Sendable where Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence, Upstream.Element == Swift.ArraySlice<Swift.UInt8> {
  public init(upstream: Upstream)
}
extension OpenAPIRuntime.JSONSequenceSerializationSequence : _Concurrency.AsyncSequence {
  public typealias Element = Swift.ArraySlice<Swift.UInt8>
  public struct Iterator<UpstreamIterator> : _Concurrency.AsyncIteratorProtocol where UpstreamIterator : _Concurrency.AsyncIteratorProtocol, UpstreamIterator.Element == Swift.ArraySlice<Swift.UInt8> {
    public mutating func next() async throws -> Swift.ArraySlice<Swift.UInt8>?
    public typealias Element = Swift.ArraySlice<Swift.UInt8>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> OpenAPIRuntime.JSONSequenceSerializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  public typealias AsyncIterator = OpenAPIRuntime.JSONSequenceSerializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension _Concurrency.AsyncSequence where Self : Swift.Sendable, Self.Element : Swift.Encodable, Self.Element : Swift.Sendable {
  public func asEncodedJSONSequence(encoder: Foundation.JSONEncoder = {
            let encoder = JSONEncoder()
            encoder.outputFormatting = [.sortedKeys, .withoutEscapingSlashes]
            return encoder
        }()) -> OpenAPIRuntime.JSONSequenceSerializationSequence<_Concurrency.AsyncThrowingMapSequence<Self, Swift.ArraySlice<Swift.UInt8>>>
}
public struct ServerSentEventWithJSONData<JSONDataType> : Swift.Sendable, Swift.Hashable where JSONDataType : Swift.Hashable, JSONDataType : Swift.Sendable {
  public var event: Swift.String?
  public var data: JSONDataType?
  public var id: Swift.String?
  public var retry: Swift.Int64?
  public init(event: Swift.String? = nil, data: JSONDataType? = nil, id: Swift.String? = nil, retry: Swift.Int64? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.ServerSentEventWithJSONData<JSONDataType>, b: OpenAPIRuntime.ServerSentEventWithJSONData<JSONDataType>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ServerSentEvent : Swift.Sendable, Swift.Hashable {
  public var id: Swift.String?
  public var event: Swift.String?
  public var data: Swift.String?
  public var retry: Swift.Int64?
  public init(id: Swift.String? = nil, event: Swift.String? = nil, data: Swift.String? = nil, retry: Swift.Int64? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.ServerSentEvent, b: OpenAPIRuntime.ServerSentEvent) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ServerSentEventsDeserializationSequence<Upstream> : Swift.Sendable where Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence, Upstream.Element == Swift.ArraySlice<Swift.UInt8> {
  public init(upstream: Upstream, while predicate: @escaping @Sendable (Swift.ArraySlice<Swift.UInt8>) -> Swift.Bool)
}
extension OpenAPIRuntime.ServerSentEventsDeserializationSequence : _Concurrency.AsyncSequence {
  public typealias Element = OpenAPIRuntime.ServerSentEvent
  public struct Iterator<UpstreamIterator> : _Concurrency.AsyncIteratorProtocol where UpstreamIterator : _Concurrency.AsyncIteratorProtocol, UpstreamIterator.Element == Swift.ArraySlice<Swift.UInt8> {
    public mutating func next() async throws -> OpenAPIRuntime.ServerSentEvent?
    public typealias Element = OpenAPIRuntime.ServerSentEvent
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> OpenAPIRuntime.ServerSentEventsDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  public typealias AsyncIterator = OpenAPIRuntime.ServerSentEventsDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension _Concurrency.AsyncSequence where Self : Swift.Sendable, Self.Element == Swift.ArraySlice<Swift.UInt8> {
  public func asDecodedServerSentEvents(while predicate: @escaping @Sendable (Swift.ArraySlice<Swift.UInt8>) -> Swift.Bool = { _ in true }) -> OpenAPIRuntime.ServerSentEventsDeserializationSequence<OpenAPIRuntime.ServerSentEventsLineDeserializationSequence<Self>>
  public func asDecodedServerSentEventsWithJSONData<JSONDataType>(of dataType: JSONDataType.Type = JSONDataType.self, decoder: Foundation.JSONDecoder = .init(), while predicate: @escaping @Sendable (Swift.ArraySlice<Swift.UInt8>) -> Swift.Bool = { _ in true }) -> _Concurrency.AsyncThrowingMapSequence<OpenAPIRuntime.ServerSentEventsDeserializationSequence<OpenAPIRuntime.ServerSentEventsLineDeserializationSequence<Self>>, OpenAPIRuntime.ServerSentEventWithJSONData<JSONDataType>> where JSONDataType : Swift.Decodable, JSONDataType : Swift.Hashable, JSONDataType : Swift.Sendable
}
public struct ServerSentEventsLineDeserializationSequence<Upstream> : Swift.Sendable where Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence, Upstream.Element == Swift.ArraySlice<Swift.UInt8> {
  public init(upstream: Upstream)
}
extension OpenAPIRuntime.ServerSentEventsLineDeserializationSequence : _Concurrency.AsyncSequence {
  public typealias Element = Swift.ArraySlice<Swift.UInt8>
  public struct Iterator<UpstreamIterator> : _Concurrency.AsyncIteratorProtocol where UpstreamIterator : _Concurrency.AsyncIteratorProtocol, UpstreamIterator.Element == Swift.ArraySlice<Swift.UInt8> {
    public mutating func next() async throws -> Swift.ArraySlice<Swift.UInt8>?
    public typealias Element = Swift.ArraySlice<Swift.UInt8>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> OpenAPIRuntime.ServerSentEventsLineDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  public typealias AsyncIterator = OpenAPIRuntime.ServerSentEventsLineDeserializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
public struct ServerSentEventsSerializationSequence<Upstream> : Swift.Sendable where Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence, Upstream.Element == OpenAPIRuntime.ServerSentEvent {
  public init(upstream: Upstream)
}
extension OpenAPIRuntime.ServerSentEventsSerializationSequence : _Concurrency.AsyncSequence {
  public typealias Element = Swift.ArraySlice<Swift.UInt8>
  public struct Iterator<UpstreamIterator> : _Concurrency.AsyncIteratorProtocol where UpstreamIterator : _Concurrency.AsyncIteratorProtocol, UpstreamIterator.Element == OpenAPIRuntime.ServerSentEvent {
    public mutating func next() async throws -> Swift.ArraySlice<Swift.UInt8>?
    public typealias Element = Swift.ArraySlice<Swift.UInt8>
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> OpenAPIRuntime.ServerSentEventsSerializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  public typealias AsyncIterator = OpenAPIRuntime.ServerSentEventsSerializationSequence<Upstream>.Iterator<Upstream.AsyncIterator>
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension _Concurrency.AsyncSequence {
  public func asEncodedServerSentEvents() -> OpenAPIRuntime.ServerSentEventsSerializationSequence<Self> where Self : Swift.Sendable, Self.Element == OpenAPIRuntime.ServerSentEvent
  public func asEncodedServerSentEventsWithJSONData<JSONDataType>(encoder: Foundation.JSONEncoder = {
            let encoder = JSONEncoder()
            encoder.outputFormatting = [.sortedKeys, .withoutEscapingSlashes]
            return encoder
        }()) -> OpenAPIRuntime.ServerSentEventsSerializationSequence<_Concurrency.AsyncThrowingMapSequence<Self, OpenAPIRuntime.ServerSentEvent>> where Self : Swift.Sendable, JSONDataType : Swift.Encodable, JSONDataType : Swift.Hashable, JSONDataType : Swift.Sendable, Self.Element == OpenAPIRuntime.ServerSentEventWithJSONData<JSONDataType>
}
public enum IterationBehavior : Swift.Sendable {
  case single
  case multiple
  public static func == (a: OpenAPIRuntime.IterationBehavior, b: OpenAPIRuntime.IterationBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@usableFromInline
internal struct AnyIterator<Element> : _Concurrency.AsyncIteratorProtocol where Element : Swift.Sendable {
  @usableFromInline
  internal init<Iterator>(_ iterator: Iterator) where Element == Iterator.Element, Iterator : _Concurrency.AsyncIteratorProtocol
  public mutating func next() async throws -> Element?
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  @_implements(_Concurrency.AsyncIteratorProtocol, Failure) internal typealias __AsyncIteratorProtocol_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  internal typealias __AsyncIteratorProtocol_Failure = any Swift.Error
  #endif
}
@usableFromInline
internal struct AnySequence<Element> : _Concurrency.AsyncSequence, Swift.Sendable where Element : Swift.Sendable {
  @usableFromInline
  internal typealias AsyncIterator = OpenAPIRuntime.AnyIterator<Element>
  @usableFromInline
  internal let produceIterator: @Sendable () -> OpenAPIRuntime.AnySequence<Element>.AsyncIterator
  @usableFromInline
  internal init<Upstream>(_ sequence: Upstream) where Element == Upstream.Element, Upstream : Swift.Sendable, Upstream : _Concurrency.AsyncSequence
  @usableFromInline
  internal func makeAsyncIterator() -> OpenAPIRuntime.AnySequence<Element>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  @_implements(_Concurrency.AsyncSequence, Failure) internal typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  internal typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
@usableFromInline
internal struct WrappedSyncSequence<Upstream> : _Concurrency.AsyncSequence, Swift.Sendable where Upstream : Swift.Sendable, Upstream : Swift.Sequence, Upstream.Element : Swift.Sendable {
  @usableFromInline
  internal typealias AsyncIterator = OpenAPIRuntime.WrappedSyncSequence<Upstream>.Iterator<OpenAPIRuntime.WrappedSyncSequence<Upstream>.Element>
  @usableFromInline
  internal typealias Element = Upstream.Element
  @usableFromInline
  internal struct Iterator<IteratorElement> : _Concurrency.AsyncIteratorProtocol where IteratorElement : Swift.Sendable {
    @usableFromInline
    internal typealias Element = IteratorElement
    @usableFromInline
    internal mutating func next() async throws -> IteratorElement?
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @usableFromInline
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) internal typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @usableFromInline
    internal typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  @usableFromInline
  internal let sequence: Upstream
  @usableFromInline
  internal init(sequence: Upstream)
  @usableFromInline
  internal func makeAsyncIterator() -> OpenAPIRuntime.WrappedSyncSequence<Upstream>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  @_implements(_Concurrency.AsyncSequence, Failure) internal typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  internal typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
@usableFromInline
internal struct EmptySequence<Element> : _Concurrency.AsyncSequence, Swift.Sendable where Element : Swift.Sendable {
  @usableFromInline
  internal typealias AsyncIterator = OpenAPIRuntime.EmptySequence<Element>.EmptyIterator<Element>
  @usableFromInline
  internal struct EmptyIterator<IteratorElement> : _Concurrency.AsyncIteratorProtocol where IteratorElement : Swift.Sendable {
    @usableFromInline
    internal mutating func next() async throws -> IteratorElement?
    @usableFromInline
    internal typealias Element = IteratorElement
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @usableFromInline
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) internal typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @usableFromInline
    internal typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  @usableFromInline
  internal init()
  @usableFromInline
  internal func makeAsyncIterator() -> OpenAPIRuntime.EmptySequence<Element>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  @_implements(_Concurrency.AsyncSequence, Failure) internal typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @usableFromInline
  internal typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
public protocol ClientTransport : Swift.Sendable {
  func send(_ request: HTTPTypes.HTTPRequest, body: OpenAPIRuntime.HTTPBody?, baseURL: Foundation.URL, operationID: Swift.String) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?)
}
public protocol ClientMiddleware : Swift.Sendable {
  func intercept(_ request: HTTPTypes.HTTPRequest, body: OpenAPIRuntime.HTTPBody?, baseURL: Foundation.URL, operationID: Swift.String, next: @Sendable (HTTPTypes.HTTPRequest, OpenAPIRuntime.HTTPBody?, Foundation.URL) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?)) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?)
}
public struct ServerRequestMetadata : Swift.Hashable, Swift.Sendable {
  public var pathParameters: [Swift.String : Swift.Substring]
  public init(pathParameters: [Swift.String : Swift.Substring] = [:])
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.ServerRequestMetadata, b: OpenAPIRuntime.ServerRequestMetadata) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension OpenAPIRuntime.ServerRequestMetadata : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct ErrorHandlingMiddleware : OpenAPIRuntime.ServerMiddleware {
  public init()
  public func intercept(_ request: HTTPTypes.HTTPRequest, body: OpenAPIRuntime.HTTPBody?, metadata: OpenAPIRuntime.ServerRequestMetadata, operationID: Swift.String, next: @Sendable (HTTPTypes.HTTPRequest, OpenAPIRuntime.HTTPBody?, OpenAPIRuntime.ServerRequestMetadata) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?)) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?)
}
public protocol HTTPResponseConvertible {
  var httpStatus: HTTPTypes.HTTPResponse.Status { get }
  var httpHeaderFields: HTTPTypes.HTTPFields { get }
  var httpBody: OpenAPIRuntime.HTTPBody? { get }
}
extension OpenAPIRuntime.HTTPResponseConvertible {
  public var httpHeaderFields: HTTPTypes.HTTPFields {
    get
  }
  public var httpBody: OpenAPIRuntime.HTTPBody? {
    get
  }
}
final public class HTTPBody : @unchecked Swift.Sendable {
  public typealias ByteChunk = Swift.ArraySlice<Swift.UInt8>
  final public let iterationBehavior: OpenAPIRuntime.IterationBehavior
  public enum Length : Swift.Sendable, Swift.Equatable {
    case unknown
    case known(Swift.Int64)
    public static func == (a: OpenAPIRuntime.HTTPBody.Length, b: OpenAPIRuntime.HTTPBody.Length) -> Swift.Bool
  }
  final public let length: OpenAPIRuntime.HTTPBody.Length
  @usableFromInline
  internal init(_ sequence: OpenAPIRuntime.AnySequence<OpenAPIRuntime.HTTPBody.ByteChunk>, length: OpenAPIRuntime.HTTPBody.Length, iterationBehavior: OpenAPIRuntime.IterationBehavior)
  @usableFromInline
  convenience internal init(_ byteChunks: some Sequence<ByteChunk> & Sendable, length: OpenAPIRuntime.HTTPBody.Length, iterationBehavior: OpenAPIRuntime.IterationBehavior)
  @objc deinit
}
extension OpenAPIRuntime.HTTPBody : Swift.Equatable {
  public static func == (lhs: OpenAPIRuntime.HTTPBody, rhs: OpenAPIRuntime.HTTPBody) -> Swift.Bool
}
extension OpenAPIRuntime.HTTPBody : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension OpenAPIRuntime.HTTPBody {
  @inlinable convenience public init() {
        self.init(.init(EmptySequence()), length: .known(0), iterationBehavior: .multiple)
    }
  @inlinable convenience public init(_ bytes: OpenAPIRuntime.HTTPBody.ByteChunk, length: OpenAPIRuntime.HTTPBody.Length) {
        self.init([bytes], length: length, iterationBehavior: .multiple)
    }
  @inlinable convenience public init(_ bytes: OpenAPIRuntime.HTTPBody.ByteChunk) {
        self.init([bytes], length: .known(Int64(bytes.count)), iterationBehavior: .multiple)
    }
  @inlinable convenience public init(_ bytes: some Sequence<UInt8> & Sendable, length: OpenAPIRuntime.HTTPBody.Length, iterationBehavior: OpenAPIRuntime.IterationBehavior) { self.init([ArraySlice(bytes)], length: length, iterationBehavior: iterationBehavior) }
  @inlinable convenience public init(_ bytes: some Collection<UInt8> & Sendable, length: OpenAPIRuntime.HTTPBody.Length) {
        self.init(ArraySlice(bytes), length: length, iterationBehavior: .multiple)
    }
  @inlinable convenience public init(_ bytes: some Collection<UInt8> & Sendable) {
        self.init(bytes, length: .known(Int64(bytes.count)))
    }
  @inlinable convenience public init(_ stream: _Concurrency.AsyncThrowingStream<OpenAPIRuntime.HTTPBody.ByteChunk, any Swift.Error>, length: OpenAPIRuntime.HTTPBody.Length) {
        self.init(.init(stream), length: length, iterationBehavior: .single)
    }
  @inlinable convenience public init(_ stream: _Concurrency.AsyncStream<OpenAPIRuntime.HTTPBody.ByteChunk>, length: OpenAPIRuntime.HTTPBody.Length) {
        self.init(.init(stream), length: length, iterationBehavior: .single)
    }
  @inlinable convenience public init<Bytes>(_ sequence: Bytes, length: OpenAPIRuntime.HTTPBody.Length, iterationBehavior: OpenAPIRuntime.IterationBehavior) where Bytes : Swift.Sendable, Bytes : _Concurrency.AsyncSequence, Bytes.Element == Swift.ArraySlice<Swift.UInt8> {
        self.init(.init(sequence), length: length, iterationBehavior: iterationBehavior)
    }
  @inlinable convenience public init<Bytes>(_ sequence: Bytes, length: OpenAPIRuntime.HTTPBody.Length, iterationBehavior: OpenAPIRuntime.IterationBehavior) where Bytes : Swift.Sendable, Bytes : _Concurrency.AsyncSequence, Bytes.Element : Swift.Sendable, Bytes.Element : Swift.Sequence, Bytes.Element.Element == Swift.UInt8 {
        self.init(sequence.map { ArraySlice($0) }, length: length, iterationBehavior: iterationBehavior)
    }
}
extension OpenAPIRuntime.HTTPBody : _Concurrency.AsyncSequence {
  public typealias Element = OpenAPIRuntime.HTTPBody.ByteChunk
  public typealias AsyncIterator = OpenAPIRuntime.HTTPBody.Iterator
  final public func makeAsyncIterator() -> OpenAPIRuntime.HTTPBody.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension Swift.ArraySlice where Element == Swift.UInt8 {
  public init(collecting body: OpenAPIRuntime.HTTPBody, upTo maxBytes: Swift.Int) async throws
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(collecting body: OpenAPIRuntime.HTTPBody, upTo maxBytes: Swift.Int) async throws
}
extension OpenAPIRuntime.HTTPBody {
  @inlinable convenience public init(_ string: some StringProtocol & Sendable, length: OpenAPIRuntime.HTTPBody.Length) {
        self.init(ByteChunk(string), length: length)
    }
  @inlinable convenience public init(_ string: some StringProtocol & Sendable) { self.init(ByteChunk(string)) }
  @inlinable convenience public init(_ stream: _Concurrency.AsyncThrowingStream<some StringProtocol & Sendable, any Swift.Error>, length: OpenAPIRuntime.HTTPBody.Length) { self.init(.init(stream.map { ByteChunk.init($0) }), length: length, iterationBehavior: .single) }
  @inlinable convenience public init(_ stream: _Concurrency.AsyncStream<some StringProtocol & Sendable>, length: OpenAPIRuntime.HTTPBody.Length) {
        self.init(.init(stream.map { ByteChunk.init($0) }), length: length, iterationBehavior: .single)
    }
  @inlinable convenience public init<Strings>(_ sequence: Strings, length: OpenAPIRuntime.HTTPBody.Length, iterationBehavior: OpenAPIRuntime.IterationBehavior) where Strings : Swift.Sendable, Strings : _Concurrency.AsyncSequence, Strings.Element : Swift.Sendable, Strings.Element : Swift.StringProtocol {
        self.init(.init(sequence.map { ByteChunk.init($0) }), length: length, iterationBehavior: iterationBehavior)
    }
}
extension Swift.ArraySlice where Element == Swift.UInt8 {
  @inlinable internal init(_ string: some StringProtocol & Sendable) { self = Array(string.utf8)[...] }
}
extension Swift.String {
  public init(collecting body: OpenAPIRuntime.HTTPBody, upTo maxBytes: Swift.Int) async throws
}
extension OpenAPIRuntime.HTTPBody : Swift.ExpressibleByStringLiteral {
  convenience public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension OpenAPIRuntime.HTTPBody {
  @inlinable convenience public init(_ bytes: [Swift.UInt8]) { self.init(bytes[...]) }
}
extension OpenAPIRuntime.HTTPBody : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Swift.UInt8
  convenience public init(arrayLiteral elements: Swift.UInt8...)
}
extension OpenAPIRuntime.HTTPBody {
  convenience public init(_ data: Foundation.Data)
}
extension Foundation.Data {
  public init(collecting body: OpenAPIRuntime.HTTPBody, upTo maxBytes: Swift.Int) async throws
}
extension OpenAPIRuntime.HTTPBody {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public typealias Element = OpenAPIRuntime.HTTPBody.ByteChunk
    @usableFromInline
    internal init<Iterator>(_ iterator: Iterator) where Iterator : _Concurrency.AsyncIteratorProtocol, Iterator.Element == Swift.ArraySlice<Swift.UInt8>
    public mutating func next() async throws -> OpenAPIRuntime.HTTPBody.Iterator.Element?
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
public protocol ServerTransport {
  func register(_ handler: @escaping @Sendable (HTTPTypes.HTTPRequest, OpenAPIRuntime.HTTPBody?, OpenAPIRuntime.ServerRequestMetadata) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?), method: HTTPTypes.HTTPRequest.Method, path: Swift.String) throws
}
public protocol ServerMiddleware : Swift.Sendable {
  func intercept(_ request: HTTPTypes.HTTPRequest, body: OpenAPIRuntime.HTTPBody?, metadata: OpenAPIRuntime.ServerRequestMetadata, operationID: Swift.String, next: @Sendable (HTTPTypes.HTTPRequest, OpenAPIRuntime.HTTPBody?, OpenAPIRuntime.ServerRequestMetadata) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?)) async throws -> (HTTPTypes.HTTPResponse, OpenAPIRuntime.HTTPBody?)
}
public protocol MultipartBoundaryGenerator : Swift.Sendable {
  func makeBoundary() -> Swift.String
}
extension OpenAPIRuntime.MultipartBoundaryGenerator where Self == OpenAPIRuntime.ConstantMultipartBoundaryGenerator {
  public static var constant: OpenAPIRuntime.ConstantMultipartBoundaryGenerator {
    get
  }
}
extension OpenAPIRuntime.MultipartBoundaryGenerator where Self == OpenAPIRuntime.RandomMultipartBoundaryGenerator {
  public static var random: OpenAPIRuntime.RandomMultipartBoundaryGenerator {
    get
  }
}
public struct ConstantMultipartBoundaryGenerator : OpenAPIRuntime.MultipartBoundaryGenerator {
  public let boundary: Swift.String
  public init(boundary: Swift.String = "__X_SWIFT_OPENAPI_GENERATOR_BOUNDARY__")
  public func makeBoundary() -> Swift.String
}
public struct RandomMultipartBoundaryGenerator : OpenAPIRuntime.MultipartBoundaryGenerator {
  public let boundaryPrefix: Swift.String
  public let randomNumberSuffixLength: Swift.Int
  public init(boundaryPrefix: Swift.String = "__X_SWIFT_OPENAPI_", randomNumberSuffixLength: Swift.Int = 20)
  public func makeBoundary() -> Swift.String
}
public struct MultipartRawPart : Swift.Sendable, Swift.Hashable {
  public var headerFields: HTTPTypes.HTTPFields
  public var body: OpenAPIRuntime.HTTPBody
  public init(headerFields: HTTPTypes.HTTPFields, body: OpenAPIRuntime.HTTPBody)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.MultipartRawPart, b: OpenAPIRuntime.MultipartRawPart) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MultipartPart<Payload> : Swift.Sendable, Swift.Hashable where Payload : Swift.Hashable, Payload : Swift.Sendable {
  public var payload: Payload
  public var filename: Swift.String?
  public init(payload: Payload, filename: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.MultipartPart<Payload>, b: OpenAPIRuntime.MultipartPart<Payload>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct MultipartDynamicallyNamedPart<Payload> : Swift.Sendable, Swift.Hashable where Payload : Swift.Hashable, Payload : Swift.Sendable {
  public var payload: Payload
  public var filename: Swift.String?
  public var name: Swift.String?
  public init(payload: Payload, filename: Swift.String? = nil, name: Swift.String? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OpenAPIRuntime.MultipartDynamicallyNamedPart<Payload>, b: OpenAPIRuntime.MultipartDynamicallyNamedPart<Payload>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
final public class MultipartBody<Part> : @unchecked Swift.Sendable where Part : Swift.Sendable {
  final public let iterationBehavior: OpenAPIRuntime.IterationBehavior
  @usableFromInline
  internal init(_ sequence: OpenAPIRuntime.AnySequence<Part>, iterationBehavior: OpenAPIRuntime.IterationBehavior)
  @objc deinit
}
extension OpenAPIRuntime.MultipartBody : Swift.Equatable {
  public static func == (lhs: OpenAPIRuntime.MultipartBody<Part>, rhs: OpenAPIRuntime.MultipartBody<Part>) -> Swift.Bool
}
extension OpenAPIRuntime.MultipartBody : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension OpenAPIRuntime.MultipartBody {
  @inlinable convenience public init<Input>(_ sequence: Input, iterationBehavior: OpenAPIRuntime.IterationBehavior) where Part == Input.Element, Input : Swift.Sendable, Input : _Concurrency.AsyncSequence { self.init(.init(sequence), iterationBehavior: iterationBehavior) }
  @usableFromInline
  convenience internal init(_ elements: some Sequence<Element> & Sendable, iterationBehavior: OpenAPIRuntime.IterationBehavior)
  @inlinable convenience public init(_ elements: some Collection<Element> & Sendable) {
        self.init(elements, iterationBehavior: .multiple)
    }
  @inlinable convenience public init(_ stream: _Concurrency.AsyncThrowingStream<OpenAPIRuntime.MultipartBody<Part>.Element, any Swift.Error>) {
        self.init(.init(stream), iterationBehavior: .single)
    }
  @inlinable convenience public init(_ stream: _Concurrency.AsyncStream<OpenAPIRuntime.MultipartBody<Part>.Element>) {
        self.init(.init(stream), iterationBehavior: .single)
    }
}
extension OpenAPIRuntime.MultipartBody : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = OpenAPIRuntime.MultipartBody<Part>.Element
  convenience public init(arrayLiteral elements: OpenAPIRuntime.MultipartBody<Part>.Element...)
}
extension OpenAPIRuntime.MultipartBody : _Concurrency.AsyncSequence {
  public typealias Element = Part
  public typealias AsyncIterator = OpenAPIRuntime.MultipartBody<Part>.Iterator
  final public func makeAsyncIterator() -> OpenAPIRuntime.MultipartBody<Part>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
extension OpenAPIRuntime.MultipartBody {
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    @usableFromInline
    internal init<Iterator>(_ iterator: Iterator) where Part == Iterator.Element, Iterator : _Concurrency.AsyncIteratorProtocol
    public mutating func next() async throws -> OpenAPIRuntime.MultipartBody<Part>.Element?
    public typealias Element = OpenAPIRuntime.MultipartBody<Part>.Element
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
extension OpenAPIRuntime.MultipartRawPart {
  public init(name: Swift.String?, filename: Swift.String? = nil, headerFields: HTTPTypes.HTTPFields, body: OpenAPIRuntime.HTTPBody)
  public var name: Swift.String? {
    get
    set
  }
  public var filename: Swift.String? {
    get
    set
  }
}
extension OpenAPIRuntime.IterationBehavior : Swift.Equatable {}
extension OpenAPIRuntime.IterationBehavior : Swift.Hashable {}
