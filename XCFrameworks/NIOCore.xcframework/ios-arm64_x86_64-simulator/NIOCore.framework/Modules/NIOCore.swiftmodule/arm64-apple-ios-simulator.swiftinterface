// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-upcoming-feature StrictConcurrency -enable-upcoming-feature InferSendableFromCaptures -enable-upcoming-feature MemberImportVisibility -enable-bare-slash-regex -module-name NIOCore -package-name swift_nio
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Atomics
import Darwin.C
import Darwin
import DequeModule
import Dispatch
import NIOConcurrencyHelpers
import Swift
import _Concurrency
import _NIOBase64
import _NIODataStructures
import _StringProcessing
import _SwiftConcurrencyShims
public struct AddressedEnvelope<DataType> {
  public var remoteAddress: NIOCore.SocketAddress
  public var data: DataType
  public var metadata: NIOCore.AddressedEnvelope<DataType>.Metadata?
  public init(remoteAddress: NIOCore.SocketAddress, data: DataType)
  public init(remoteAddress: NIOCore.SocketAddress, data: DataType, metadata: NIOCore.AddressedEnvelope<DataType>.Metadata?)
  public struct Metadata : Swift.Hashable, Swift.Sendable {
    public var ecnState: NIOCore.NIOExplicitCongestionNotificationState
    public var packetInfo: NIOCore.NIOPacketInfo?
    public init(ecnState: NIOCore.NIOExplicitCongestionNotificationState)
    public init(ecnState: NIOCore.NIOExplicitCongestionNotificationState, packetInfo: NIOCore.NIOPacketInfo?)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NIOCore.AddressedEnvelope<DataType>.Metadata, b: NIOCore.AddressedEnvelope<DataType>.Metadata) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension NIOCore.AddressedEnvelope : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NIOCore.AddressedEnvelope : Swift.Equatable where DataType : Swift.Equatable {
  public static func == (a: NIOCore.AddressedEnvelope<DataType>, b: NIOCore.AddressedEnvelope<DataType>) -> Swift.Bool
}
extension NIOCore.AddressedEnvelope : Swift.Hashable where DataType : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.AddressedEnvelope : Swift.Sendable where DataType : Swift.Sendable {
}
public enum NIOExplicitCongestionNotificationState : Swift.Hashable, Swift.Sendable {
  case transportNotCapable
  case transportCapableFlag0
  case transportCapableFlag1
  case congestionExperienced
  public static func == (a: NIOCore.NIOExplicitCongestionNotificationState, b: NIOCore.NIOExplicitCongestionNotificationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct NIOPacketInfo : Swift.Hashable, Swift.Sendable {
  public var destinationAddress: NIOCore.SocketAddress
  public var interfaceIndex: Swift.Int
  public init(destinationAddress: NIOCore.SocketAddress, interfaceIndex: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NIOCore.NIOPacketInfo, b: NIOCore.NIOPacketInfo) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.EventLoopFuture {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @preconcurrency final public func get() async throws -> Value where Value : Swift.Sendable
}
extension NIOCore.EventLoopGroup {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func shutdownGracefully() async throws
}
extension NIOCore.EventLoopPromise {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @discardableResult
  @preconcurrency public func completeWithTask(_ body: @escaping @Sendable () async throws -> Value) -> _Concurrency.Task<Swift.Void, Swift.Never> where Value : Swift.Sendable
}
extension NIOCore.Channel {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @preconcurrency public func writeAndFlush<T>(_ data: T) async throws where T : Swift.Sendable
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func setOption<Option>(_ option: Option, value: Option.Value) async throws where Option : NIOCore.ChannelOption
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func getOption<Option>(_ option: Option) async throws -> Option.Value where Option : NIOCore.ChannelOption
}
extension NIOCore.ChannelOutboundInvoker {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func register(file: Swift.StaticString = #fileID, line: Swift.UInt = #line) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func bind(to address: NIOCore.SocketAddress, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func connect(to address: NIOCore.SocketAddress, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @available(*, deprecated, message: "NIOAny is not Sendable: avoid wrapping the value in NIOAny to silence this warning.")
  public func writeAndFlush(_ data: NIOCore.NIOAny, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func close(mode: NIOCore.CloseMode = .all, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @preconcurrency public func triggerUserOutboundEvent(_ event: any Swift.Sendable, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) async throws
}
extension NIOCore.ChannelPipeline {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @preconcurrency final public func addHandler(_ handler: any NIOCore.ChannelHandler & Swift.Sendable, name: Swift.String? = nil, position: NIOCore.ChannelPipeline.Position = .last) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @preconcurrency final public func removeHandler(_ handler: any NIOCore.RemovableChannelHandler & Swift.Sendable) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  final public func removeHandler(name: Swift.String) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @available(*, deprecated, message: "Use .syncOperations.removeHandler(context:) instead, this method is not Sendable-safe.")
  final public func removeHandler(context: NIOCore.ChannelHandlerContext) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @available(*, deprecated, message: "ChannelHandlerContext is not Sendable and it is therefore not safe to be used outside of its EventLoop")
  @preconcurrency final public func context(handler: any NIOCore.ChannelHandler & Swift.Sendable) async throws -> NIOCore.ChannelHandlerContext
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @available(*, deprecated, message: "ChannelHandlerContext is not Sendable and it is therefore not safe to be used outside of its EventLoop")
  final public func context(name: Swift.String) async throws -> NIOCore.ChannelHandlerContext
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @available(*, deprecated, message: "ChannelHandlerContext is not Sendable and it is therefore not safe to be used outside of its EventLoop")
  final public func context<Handler>(handlerType: Handler.Type) async throws -> NIOCore.ChannelHandlerContext where Handler : NIOCore.ChannelHandler
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @preconcurrency final public func addHandlers(_ handlers: [any NIOCore.ChannelHandler & Swift.Sendable], position: NIOCore.ChannelPipeline.Position = .last) async throws
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  @preconcurrency final public func addHandlers(_ handlers: (any NIOCore.ChannelHandler & Swift.Sendable)..., position: NIOCore.ChannelPipeline.Position = .last) async throws
}
public struct NIOTooManyBytesError : Swift.Error {
  public var maxBytes: Swift.Int?
  @available(*, deprecated, message: "Construct the NIOTooManyBytesError with the maxBytes limit that triggered this error")
  public init()
  public init(maxBytes: Swift.Int)
}
extension NIOCore.NIOTooManyBytesError : Swift.Equatable {
  public static func == (lhs: NIOCore.NIOTooManyBytesError, rhs: NIOCore.NIOTooManyBytesError) -> Swift.Bool
}
extension NIOCore.NIOTooManyBytesError : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension _Concurrency.AsyncSequence where Self.Element : Swift.RandomAccessCollection, Self.Element.Element == Swift.UInt8 {
  public func collect(upTo maxBytes: Swift.Int, into accumulationBuffer: inout NIOCore.ByteBuffer) async throws
  public func collect(upTo maxBytes: Swift.Int, using allocator: NIOCore.ByteBufferAllocator) async throws -> NIOCore.ByteBuffer
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension _Concurrency.AsyncSequence where Self.Element == NIOCore.ByteBuffer {
  public func collect(upTo maxBytes: Swift.Int, into accumulationBuffer: inout NIOCore.ByteBuffer) async throws
  public func collect(upTo maxBytes: Swift.Int) async throws -> NIOCore.ByteBuffer
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.EventLoop {
  @preconcurrency public func makeFutureWithTask<Return>(_ body: @escaping @Sendable () async throws -> Return) -> NIOCore.EventLoopFuture<Return> where Return : Swift.Sendable
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOAsyncChannel<Inbound, Outbound> : Swift.Sendable where Inbound : Swift.Sendable, Outbound : Swift.Sendable {
  public struct Configuration : Swift.Sendable {
    public var backPressureStrategy: NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark
    public var isOutboundHalfClosureEnabled: Swift.Bool
    public var inboundType: Inbound.Type
    public var outboundType: Outbound.Type
    public init(backPressureStrategy: NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark = .init(
                lowWatermark: 2,
                highWatermark: 10
            ), isOutboundHalfClosureEnabled: Swift.Bool = false, inboundType: Inbound.Type = Inbound.self, outboundType: Outbound.Type = Outbound.self)
  }
  public let channel: any NIOCore.Channel
  @available(*, deprecated, message: "Use the executeThenClose scoped method instead.")
  public var inbound: NIOCore.NIOAsyncChannelInboundStream<Inbound> {
    get
  }
  @available(*, deprecated, message: "Use the executeThenClose scoped method instead.")
  public var outbound: NIOCore.NIOAsyncChannelOutboundWriter<Outbound> {
    get
  }
  public init(wrappingChannelSynchronously channel: any NIOCore.Channel, configuration: NIOCore.NIOAsyncChannel<Inbound, Outbound>.Configuration = .init()) throws
  public init(wrappingChannelSynchronously channel: any NIOCore.Channel, configuration: NIOCore.NIOAsyncChannel<Inbound, Outbound>.Configuration = .init()) throws where Outbound == Swift.Never
  @available(*, deprecated, renamed: "init(wrappingChannelSynchronously:configuration:)", message: "This method has been deprecated since it defaults to deinit based resource teardown")
  public init(synchronouslyWrapping channel: any NIOCore.Channel, configuration: NIOCore.NIOAsyncChannel<Inbound, Outbound>.Configuration = .init()) throws
  @available(*, deprecated, renamed: "init(wrappingChannelSynchronously:configuration:)", message: "This method has been deprecated since it defaults to deinit based resource teardown")
  public init(synchronouslyWrapping channel: any NIOCore.Channel, configuration: NIOCore.NIOAsyncChannel<Inbound, Outbound>.Configuration = .init()) throws where Outbound == Swift.Never
  @available(*, deprecated, message: "This method has been deprecated since it defaults to deinit based resource teardown")
  public static func _wrapAsyncChannelWithTransformations(synchronouslyWrapping channel: any NIOCore.Channel, backPressureStrategy: NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark? = nil, isOutboundHalfClosureEnabled: Swift.Bool = false, channelReadTransformation: @escaping @Sendable (any NIOCore.Channel) -> NIOCore.EventLoopFuture<Inbound>) throws -> NIOCore.NIOAsyncChannel<Inbound, Outbound> where Outbound == Swift.Never
  public static func _wrapAsyncChannelWithTransformations(wrappingChannelSynchronously channel: any NIOCore.Channel, backPressureStrategy: NIOCore.NIOAsyncSequenceProducerBackPressureStrategies.HighLowWatermark? = nil, isOutboundHalfClosureEnabled: Swift.Bool = false, channelReadTransformation: @escaping @Sendable (any NIOCore.Channel) -> NIOCore.EventLoopFuture<Inbound>) throws -> NIOCore.NIOAsyncChannel<Inbound, Outbound> where Outbound == Swift.Never
  @_disfavoredOverload public func executeThenClose<Result>(_ body: (_ inbound: NIOCore.NIOAsyncChannelInboundStream<Inbound>, _ outbound: NIOCore.NIOAsyncChannelOutboundWriter<Outbound>) async throws -> Result) async throws -> Result
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func executeThenClose<Result>(isolation actor: isolated (any _Concurrency.Actor)? = #isolation, _ body: (_ inbound: NIOCore.NIOAsyncChannelInboundStream<Inbound>, _ outbound: NIOCore.NIOAsyncChannelOutboundWriter<Outbound>) async throws -> sending Result) async throws -> sending Result
  #else
  public func executeThenClose<Result>(isolation actor: isolated (any _Concurrency.Actor)? = #isolation, _ body: (_ inbound: NIOCore.NIOAsyncChannelInboundStream<Inbound>, _ outbound: NIOCore.NIOAsyncChannelOutboundWriter<Outbound>) async throws -> Result) async throws -> Result
  #endif
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncChannel {
  @_disfavoredOverload public func executeThenClose<Result>(_ body: (_ inbound: NIOCore.NIOAsyncChannelInboundStream<Inbound>) async throws -> Result) async throws -> Result where Outbound == Swift.Never
  #if compiler(>=5.3) && $OptionalIsolatedParameters && $ExpressionMacroDefaultArguments
  #if compiler(>=5.3) && $SendingArgsAndResults
  public func executeThenClose<Result>(isolation actor: isolated (any _Concurrency.Actor)? = #isolation, _ body: (_ inbound: NIOCore.NIOAsyncChannelInboundStream<Inbound>) async throws -> sending Result) async throws -> sending Result where Outbound == Swift.Never
  #else
  public func executeThenClose<Result>(isolation actor: isolated (any _Concurrency.Actor)? = #isolation, _ body: (_ inbound: NIOCore.NIOAsyncChannelInboundStream<Inbound>) async throws -> Result) async throws -> Result where Outbound == Swift.Never
  #endif
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOAsyncChannelInboundStream<Inbound> : Swift.Sendable where Inbound : Swift.Sendable {
  public struct TestSource {
    public func yield(_ element: Inbound)
    public func finish(throwing error: (any Swift.Error)? = nil)
  }
  public static func makeTestingStream() -> (NIOCore.NIOAsyncChannelInboundStream<Inbound>, NIOCore.NIOAsyncChannelInboundStream<Inbound>.TestSource)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncChannelInboundStream : _Concurrency.AsyncSequence {
  public typealias Element = Inbound
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async throws -> NIOCore.NIOAsyncChannelInboundStream<Inbound>.Element?
    @available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
    public typealias Element = NIOCore.NIOAsyncChannelInboundStream<Inbound>.Element
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
  public func makeAsyncIterator() -> NIOCore.NIOAsyncChannelInboundStream<Inbound>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, unavailable)
extension NIOCore.NIOAsyncChannelInboundStream.AsyncIterator : Swift.Sendable {
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOAsyncChannelOutboundWriter<OutboundOut> : Swift.Sendable where OutboundOut : Swift.Sendable {
  public struct TestSink : _Concurrency.AsyncSequence {
    public typealias Element = OutboundOut
    public func makeAsyncIterator() -> NIOCore.NIOAsyncChannelOutboundWriter<OutboundOut>.TestSink.AsyncIterator
    public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
      public mutating func next() async -> NIOCore.NIOAsyncChannelOutboundWriter<OutboundOut>.TestSink.Element?
      @available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
      public typealias Element = NIOCore.NIOAsyncChannelOutboundWriter<OutboundOut>.TestSink.Element
      #if compiler(>=5.3) && $AssociatedTypeImplements
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
      #else
      @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
      public typealias __AsyncIteratorProtocol_Failure = Swift.Never
      #endif
    }
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncSequence_Failure = Swift.Never
    #endif
  }
  public static func makeTestingWriter() -> (NIOCore.NIOAsyncChannelOutboundWriter<OutboundOut>, NIOCore.NIOAsyncChannelOutboundWriter<OutboundOut>.TestSink)
  public func write(_ data: OutboundOut) async throws
  public func write<Writes>(contentsOf sequence: Writes) async throws where OutboundOut == Writes.Element, Writes : Swift.Sequence
  public func write<Writes>(contentsOf sequence: Writes) async throws where OutboundOut == Writes.Element, Writes : _Concurrency.AsyncSequence
  public func finish()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncChannelOutboundWriter.TestSink : Swift.Sendable {
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol NIOAsyncSequenceProducerBackPressureStrategy : Swift.Sendable {
  mutating func didYield(bufferDepth: Swift.Int) -> Swift.Bool
  mutating func didConsume(bufferDepth: Swift.Int) -> Swift.Bool
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol NIOAsyncSequenceProducerDelegate : Swift.Sendable {
  func produceMore()
  func didTerminate()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOAsyncSequenceProducer<Element, Strategy, Delegate> : Swift.Sendable where Element : Swift.Sendable, Strategy : NIOCore.NIOAsyncSequenceProducerBackPressureStrategy, Delegate : NIOCore.NIOAsyncSequenceProducerDelegate {
  public struct NewSequence : Swift.Sendable {
    public let source: NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.Source
    public let sequence: NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>
  }
  public static func makeSequence(elementType: Element.Type = Element.self, backPressureStrategy: Strategy, finishOnDeinit: Swift.Bool, delegate: Delegate) -> NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.NewSequence
  @available(*, deprecated, renamed: "makeSequence(elementType:backPressureStrategy:finishOnDeinit:delegate:)", message: "This method has been deprecated since it defaults to deinit based resource teardown")
  public static func makeSequence(elementType: Element.Type = Element.self, backPressureStrategy: Strategy, delegate: Delegate) -> NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.NewSequence
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncSequenceProducer : _Concurrency.AsyncSequence {
  public func makeAsyncIterator() -> NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncSequenceProducer {
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public func next() async -> Element?
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #endif
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncSequenceProducer {
  public struct Source {
    public enum YieldResult : Swift.Hashable, Swift.Sendable {
      case produceMore
      case stopProducing
      case dropped
      public static func == (a: NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.Source.YieldResult, b: NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.Source.YieldResult) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public func yield<S>(contentsOf sequence: S) -> NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.Source.YieldResult where Element == S.Element, S : Swift.Sequence
    public func yield(_ element: Element) -> NIOCore.NIOAsyncSequenceProducer<Element, Strategy, Delegate>.Source.YieldResult
    public func finish()
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, unavailable)
extension NIOCore.NIOAsyncSequenceProducer.AsyncIterator : Swift.Sendable {
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncSequenceProducer.Source : Swift.Sendable {
}
public enum NIOAsyncSequenceProducerBackPressureStrategies {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public struct HighLowWatermark : NIOCore.NIOAsyncSequenceProducerBackPressureStrategy {
    public init(lowWatermark: Swift.Int, highWatermark: Swift.Int)
    public mutating func didYield(bufferDepth: Swift.Int) -> Swift.Bool
    public mutating func didConsume(bufferDepth: Swift.Int) -> Swift.Bool
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol NIOAsyncWriterSinkDelegate : Swift.Sendable {
  associatedtype Element : Swift.Sendable
  func didYield(contentsOf sequence: DequeModule.Deque<Self.Element>)
  func didYield(_ element: Self.Element)
  func didTerminate(error: (any Swift.Error)?)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncWriterSinkDelegate {
  public func didYield(_ element: Self.Element)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOAsyncWriterError : Swift.Error, Swift.Hashable, Swift.CustomStringConvertible {
  public var file: Swift.String
  public var line: Swift.Int
  public static func == (lhs: NIOCore.NIOAsyncWriterError, rhs: NIOCore.NIOAsyncWriterError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func alreadyFinished(file: Swift.String = #fileID, line: Swift.Int = #line) -> NIOCore.NIOAsyncWriterError
  public var description: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOAsyncWriter<Element, Delegate> : Swift.Sendable where Element == Delegate.Element, Delegate : NIOCore.NIOAsyncWriterSinkDelegate {
  public struct NewWriter {
    public let sink: NIOCore.NIOAsyncWriter<Element, Delegate>.Sink
    public let writer: NIOCore.NIOAsyncWriter<Element, Delegate>
  }
  @available(*, deprecated, renamed: "makeWriter(elementType:isWritable:finishOnDeinit:delegate:)", message: "This method has been deprecated since it defaults to deinit based resource teardown")
  public static func makeWriter(elementType: Element.Type = Element.self, isWritable: Swift.Bool, delegate: Delegate) -> NIOCore.NIOAsyncWriter<Element, Delegate>.NewWriter
  public static func makeWriter(elementType: Element.Type = Element.self, isWritable: Swift.Bool, finishOnDeinit: Swift.Bool, delegate: Delegate) -> NIOCore.NIOAsyncWriter<Element, Delegate>.NewWriter
  public func yield<S>(contentsOf sequence: S) async throws where S : Swift.Sequence, Delegate.Element == S.Element
  public func yield(_ element: Element) async throws
  public func finish()
  public func finish(error: any Swift.Error)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOAsyncWriter {
  public struct Sink {
    public func setWritability(to writability: Swift.Bool)
    public func finish()
    public func finish(error: any Swift.Error)
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate> : Swift.Sendable where Element : Swift.Sendable, Failure : Swift.Error, Strategy : NIOCore.NIOAsyncSequenceProducerBackPressureStrategy, Delegate : NIOCore.NIOAsyncSequenceProducerDelegate {
  public struct NewSequence {
    public let source: NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.Source
    public let sequence: NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>
  }
  public static func makeSequence(elementType: Element.Type = Element.self, failureType: Failure.Type = Error.self, backPressureStrategy: Strategy, finishOnDeinit: Swift.Bool, delegate: Delegate) -> NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.NewSequence where Failure == any Swift.Error
  @available(*, deprecated, message: "Support for a generic Failure type is deprecated. Failure type must be `any Swift.Error`.")
  public static func makeSequence(elementType: Element.Type = Element.self, failureType: Failure.Type = Failure.self, backPressureStrategy: Strategy, delegate: Delegate) -> NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.NewSequence
  @available(*, deprecated, renamed: "makeSequence(elementType:failureType:backPressureStrategy:finishOnDeinit:delegate:)", message: "This method has been deprecated since it defaults to deinit based resource teardown")
  public static func makeSequence(elementType: Element.Type = Element.self, failureType: Failure.Type = Error.self, backPressureStrategy: Strategy, delegate: Delegate) -> NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.NewSequence where Failure == any Swift.Error
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOThrowingAsyncSequenceProducer : _Concurrency.AsyncSequence {
  public func makeAsyncIterator() -> NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.AsyncIterator
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = any Swift.Error
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = any Swift.Error
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOThrowingAsyncSequenceProducer {
  public struct AsyncIterator : _Concurrency.AsyncIteratorProtocol {
    public func next() async throws -> Element?
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = any Swift.Error
    #endif
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOThrowingAsyncSequenceProducer {
  public struct Source {
    public enum YieldResult : Swift.Hashable {
      case produceMore
      case stopProducing
      case dropped
      public static func == (a: NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.Source.YieldResult, b: NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.Source.YieldResult) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public func yield<S>(contentsOf sequence: S) -> NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.Source.YieldResult where Element == S.Element, S : Swift.Sequence
    public func yield(_ element: Element) -> NIOCore.NIOThrowingAsyncSequenceProducer<Element, Failure, Strategy, Delegate>.Source.YieldResult
    public func finish()
    public func finish(_ failure: Failure)
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, unavailable)
extension NIOCore.NIOThrowingAsyncSequenceProducer.AsyncIterator : Swift.Sendable {
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension NIOCore.NIOThrowingAsyncSequenceProducer.Source : Swift.Sendable {
}
public enum NIOBSDSocket : Swift.Sendable {
  public typealias Handle = Swift.CInt
}
extension NIOCore.NIOBSDSocket {
  public struct AddressFamily : Swift.RawRepresentable, Swift.Sendable {
    public typealias RawValue = Swift.CInt
    public var rawValue: NIOCore.NIOBSDSocket.AddressFamily.RawValue
    public init(rawValue: NIOCore.NIOBSDSocket.AddressFamily.RawValue)
  }
}
extension NIOCore.NIOBSDSocket.AddressFamily : Swift.Equatable {
}
extension NIOCore.NIOBSDSocket.AddressFamily : Swift.Hashable {
}
extension NIOCore.NIOBSDSocket {
  public struct ProtocolFamily : Swift.RawRepresentable, Swift.Sendable {
    public typealias RawValue = Swift.CInt
    public var rawValue: NIOCore.NIOBSDSocket.ProtocolFamily.RawValue
    public init(rawValue: NIOCore.NIOBSDSocket.ProtocolFamily.RawValue)
  }
}
extension NIOCore.NIOBSDSocket.ProtocolFamily : Swift.Equatable {
}
extension NIOCore.NIOBSDSocket.ProtocolFamily : Swift.Hashable {
}
extension NIOCore.NIOBSDSocket {
  public struct OptionLevel : Swift.RawRepresentable, Swift.Sendable {
    public typealias RawValue = Swift.CInt
    public var rawValue: NIOCore.NIOBSDSocket.OptionLevel.RawValue
    public init(rawValue: NIOCore.NIOBSDSocket.OptionLevel.RawValue)
  }
}
extension NIOCore.NIOBSDSocket.OptionLevel : Swift.Equatable {
}
extension NIOCore.NIOBSDSocket.OptionLevel : Swift.Hashable {
}
extension NIOCore.NIOBSDSocket {
  public struct Option : Swift.RawRepresentable, Swift.Sendable {
    public typealias RawValue = Swift.CInt
    public var rawValue: NIOCore.NIOBSDSocket.Option.RawValue
    public init(rawValue: NIOCore.NIOBSDSocket.Option.RawValue)
  }
}
extension NIOCore.NIOBSDSocket.Option : Swift.Equatable {
}
extension NIOCore.NIOBSDSocket.Option : Swift.Hashable {
}
extension NIOCore.NIOBSDSocket.AddressFamily {
  public static let inet: NIOCore.NIOBSDSocket.AddressFamily
  public static let inet6: NIOCore.NIOBSDSocket.AddressFamily
  public static let unix: NIOCore.NIOBSDSocket.AddressFamily
}
extension NIOCore.NIOBSDSocket.ProtocolFamily {
  public static let inet: NIOCore.NIOBSDSocket.ProtocolFamily
  public static let inet6: NIOCore.NIOBSDSocket.ProtocolFamily
  public static let unix: NIOCore.NIOBSDSocket.ProtocolFamily
}
extension NIOCore.NIOBSDSocket.ProtocolFamily {
  public static let local: NIOCore.NIOBSDSocket.ProtocolFamily
}
extension NIOCore.NIOBSDSocket.OptionLevel {
  public static let ip: NIOCore.NIOBSDSocket.OptionLevel
  public static let ipv6: NIOCore.NIOBSDSocket.OptionLevel
  public static let tcp: NIOCore.NIOBSDSocket.OptionLevel
  public static let mptcp: NIOCore.NIOBSDSocket.OptionLevel
  public static let socket: NIOCore.NIOBSDSocket.OptionLevel
  public static let udp: NIOCore.NIOBSDSocket.OptionLevel
}
extension NIOCore.NIOBSDSocket.Option {
  public static let ip_add_membership: NIOCore.NIOBSDSocket.Option
  public static let ip_drop_membership: NIOCore.NIOBSDSocket.Option
  public static let ip_multicast_if: NIOCore.NIOBSDSocket.Option
  public static let ip_multicast_loop: NIOCore.NIOBSDSocket.Option
  public static let ip_multicast_ttl: NIOCore.NIOBSDSocket.Option
  public static let ip_hdrincl: NIOCore.NIOBSDSocket.Option
}
extension NIOCore.NIOBSDSocket.Option {
  public static let ipv6_join_group: NIOCore.NIOBSDSocket.Option
  public static let ipv6_leave_group: NIOCore.NIOBSDSocket.Option
  public static let ipv6_multicast_hops: NIOCore.NIOBSDSocket.Option
  public static let ipv6_multicast_if: NIOCore.NIOBSDSocket.Option
  public static let ipv6_multicast_loop: NIOCore.NIOBSDSocket.Option
  public static let ipv6_v6only: NIOCore.NIOBSDSocket.Option
}
extension NIOCore.NIOBSDSocket.Option {
  public static let tcp_nodelay: NIOCore.NIOBSDSocket.Option
}
extension NIOCore.NIOBSDSocket.Option {
  public static let tcp_connection_info: NIOCore.NIOBSDSocket.Option
}
extension NIOCore.NIOBSDSocket.Option {
  public static let mptcp_info: NIOCore.NIOBSDSocket.Option
}
extension NIOCore.NIOBSDSocket.Option {
  public static let so_error: NIOCore.NIOBSDSocket.Option
  public static let so_keepalive: NIOCore.NIOBSDSocket.Option
  public static let so_linger: NIOCore.NIOBSDSocket.Option
  public static let so_rcvbuf: NIOCore.NIOBSDSocket.Option
  public static let so_sndbuf: NIOCore.NIOBSDSocket.Option
  public static let so_rcvtimeo: NIOCore.NIOBSDSocket.Option
  public static let so_reuseaddr: NIOCore.NIOBSDSocket.Option
  public static let so_broadcast: NIOCore.NIOBSDSocket.Option
}
extension NIOCore.NIOBSDSocket.Option {
  public static let so_timestamp: NIOCore.NIOBSDSocket.Option
}
extension NIOCore.ByteBuffer {
  public func getBytes(at index: Swift.Int, length: Swift.Int) -> [Swift.UInt8]?
  public mutating func readBytes(length: Swift.Int) -> [Swift.UInt8]?
  public func peekBytes(length: Swift.Int) -> [Swift.UInt8]?
  @discardableResult
  public mutating func writeStaticString(_ string: Swift.StaticString) -> Swift.Int
  public mutating func setStaticString(_ string: Swift.StaticString, at index: Swift.Int) -> Swift.Int
  @discardableResult
  public mutating func writePlainHexEncodedBytes(_ plainHexEncodedBytes: Swift.String) throws -> Swift.Int
  @discardableResult
  public mutating func writeString(_ string: Swift.String) -> Swift.Int
  @discardableResult
  public mutating func writeNullTerminatedString(_ string: Swift.String) -> Swift.Int
  @discardableResult
  public mutating func setString(_ string: Swift.String, at index: Swift.Int) -> Swift.Int
  public mutating func setNullTerminatedString(_ string: Swift.String, at index: Swift.Int) -> Swift.Int
  public func getString(at index: Swift.Int, length: Swift.Int) -> Swift.String?
  public func getNullTerminatedString(at index: Swift.Int) -> Swift.String?
  public mutating func readString(length: Swift.Int) -> Swift.String?
  public mutating func readNullTerminatedString() -> Swift.String?
  @discardableResult
  public mutating func writeSubstring(_ substring: Swift.Substring) -> Swift.Int
  @discardableResult
  public mutating func setSubstring(_ substring: Swift.Substring, at index: Swift.Int) -> Swift.Int
  public func peekString(length: Swift.Int) -> Swift.String?
  public func peekNullTerminatedString() -> Swift.String?
  @discardableResult
  public mutating func writeDispatchData(_ dispatchData: Dispatch.DispatchData) -> Swift.Int
  @discardableResult
  public mutating func setDispatchData(_ dispatchData: Dispatch.DispatchData, at index: Swift.Int) -> Swift.Int
  public func getDispatchData(at index: Swift.Int, length: Swift.Int) -> Dispatch.DispatchData?
  public mutating func readDispatchData(length: Swift.Int) -> Dispatch.DispatchData?
  public func peekDispatchData(length: Swift.Int) -> Dispatch.DispatchData?
  @discardableResult
  public mutating func readWithUnsafeReadableBytes(_ body: (Swift.UnsafeRawBufferPointer) throws -> Swift.Int) rethrows -> Swift.Int
  @discardableResult
  public mutating func readWithUnsafeMutableReadableBytes(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> Swift.Int) rethrows -> Swift.Int
  @discardableResult
  @available(*, deprecated, renamed: "setBuffer(_:at:)")
  public mutating func set(buffer: NIOCore.ByteBuffer, at index: Swift.Int) -> Swift.Int
  @discardableResult
  public mutating func setBuffer(_ buffer: NIOCore.ByteBuffer, at index: Swift.Int) -> Swift.Int
  @discardableResult
  public mutating func writeBuffer(_ buffer: inout NIOCore.ByteBuffer) -> Swift.Int
  @discardableResult
  public mutating func writeBytes<Bytes>(_ bytes: Bytes) -> Swift.Int where Bytes : Swift.Sequence, Bytes.Element == Swift.UInt8
  @discardableResult
  public mutating func writeBytes(_ bytes: Swift.UnsafeRawBufferPointer) -> Swift.Int
  @discardableResult
  public mutating func writeRepeatingByte(_ byte: Swift.UInt8, count: Swift.Int) -> Swift.Int
  @discardableResult
  public mutating func setRepeatingByte(_ byte: Swift.UInt8, count: Swift.Int, at index: Swift.Int) -> Swift.Int
  public func slice() -> NIOCore.ByteBuffer
  public mutating func readSlice(length: Swift.Int) -> NIOCore.ByteBuffer?
  @discardableResult
  public mutating func writeImmutableBuffer(_ buffer: NIOCore.ByteBuffer) -> Swift.Int
}
extension NIOCore.ByteBuffer {
  public mutating func readWithUnsafeMutableReadableBytes<T>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> (Swift.Int, T)) rethrows -> T
  public mutating func readWithUnsafeReadableBytes<T>(_ body: (Swift.UnsafeRawBufferPointer) throws -> (Swift.Int, T)) rethrows -> T
}
extension NIOCore.ByteBuffer {
  public init()
  public init(string: Swift.String)
  public init(substring string: Swift.Substring)
  public init(staticString string: Swift.StaticString)
  public init<Bytes>(bytes: Bytes) where Bytes : Swift.Sequence, Bytes.Element == Swift.UInt8
  public init<I>(integer: I, endianness: NIOCore.Endianness = .big, as: I.Type = I.self) where I : Swift.FixedWidthInteger
  public init(repeating byte: Swift.UInt8, count: Swift.Int)
  public init(buffer: NIOCore.ByteBuffer)
  public init(dispatchData: Dispatch.DispatchData)
}
extension NIOCore.ByteBuffer : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NIOCore.ByteBufferAllocator {
  public func buffer(string: Swift.String) -> NIOCore.ByteBuffer
  public func buffer(substring string: Swift.Substring) -> NIOCore.ByteBuffer
  public func buffer(staticString string: Swift.StaticString) -> NIOCore.ByteBuffer
  public func buffer<Bytes>(bytes: Bytes) -> NIOCore.ByteBuffer where Bytes : Swift.Sequence, Bytes.Element == Swift.UInt8
  public func buffer(plainHexEncodedBytes string: Swift.String) throws -> NIOCore.ByteBuffer
  public func buffer<I>(integer: I, endianness: NIOCore.Endianness = .big, as: I.Type = I.self) -> NIOCore.ByteBuffer where I : Swift.FixedWidthInteger
  public func buffer(repeating byte: Swift.UInt8, count: Swift.Int) -> NIOCore.ByteBuffer
  public func buffer(buffer: NIOCore.ByteBuffer) -> NIOCore.ByteBuffer
  public func buffer(dispatchData: Dispatch.DispatchData) -> NIOCore.ByteBuffer
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional where Wrapped == NIOCore.ByteBuffer {
  @discardableResult
  public mutating func setOrWriteImmutableBuffer(_ buffer: NIOCore.ByteBuffer) -> Swift.Int
  @discardableResult
  public mutating func setOrWriteBuffer(_ buffer: inout NIOCore.ByteBuffer) -> Swift.Int
}
#else
extension Swift.Optional where Wrapped == NIOCore.ByteBuffer {
  @discardableResult
  public mutating func setOrWriteImmutableBuffer(_ buffer: NIOCore.ByteBuffer) -> Swift.Int
  @discardableResult
  public mutating func setOrWriteBuffer(_ buffer: inout NIOCore.ByteBuffer) -> Swift.Int
}
#endif
extension NIOCore.ByteBuffer {
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public func getUTF8ValidatedString(at index: Swift.Int, length: Swift.Int) throws -> Swift.String?
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public mutating func readUTF8ValidatedString(length: Swift.Int) throws -> Swift.String?
  public struct ReadUTF8ValidationError : Swift.Error, Swift.Equatable {
    public static let invalidUTF8: NIOCore.ByteBuffer.ReadUTF8ValidationError
    public static func == (a: NIOCore.ByteBuffer.ReadUTF8ValidationError, b: NIOCore.ByteBuffer.ReadUTF8ValidationError) -> Swift.Bool
  }
  @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
  public func peekUTF8ValidatedString(length: Swift.Int) throws -> Swift.String?
}
public protocol NIOBinaryIntegerEncodingStrategy {
  func readInteger<IntegerType>(as: IntegerType.Type, from buffer: inout NIOCore.ByteBuffer) -> IntegerType? where IntegerType : Swift.FixedWidthInteger
  func writeInteger<IntegerType>(_ integer: IntegerType, to buffer: inout NIOCore.ByteBuffer) -> Swift.Int where IntegerType : Swift.FixedWidthInteger
  var requiredBytesHint: Swift.Int { get }
  func writeInteger(_ integer: Swift.Int, reservedCapacity: Swift.Int, to buffer: inout NIOCore.ByteBuffer) -> Swift.Int
}
extension NIOCore.NIOBinaryIntegerEncodingStrategy {
  public var requiredBytesHint: Swift.Int {
    get
  }
  public func writeInteger<IntegerType>(_ integer: IntegerType, reservedCapacity: Swift.Int, to buffer: inout NIOCore.ByteBuffer) -> Swift.Int where IntegerType : Swift.FixedWidthInteger
}
extension NIOCore.ByteBuffer {
  public mutating func readEncodedInteger<Strategy, Integer>(as: Integer.Type = Integer.self, strategy: Strategy) -> Integer? where Strategy : NIOCore.NIOBinaryIntegerEncodingStrategy, Integer : Swift.FixedWidthInteger
  @discardableResult
  public mutating func writeEncodedInteger<Integer, Strategy>(_ value: Integer, strategy: Strategy) -> Swift.Int where Integer : Swift.FixedWidthInteger, Strategy : NIOCore.NIOBinaryIntegerEncodingStrategy
  @discardableResult
  public mutating func writeLengthPrefixed<Strategy>(strategy: Strategy, writeData: (_ buffer: inout NIOCore.ByteBuffer) throws -> Swift.Int) rethrows -> Swift.Int where Strategy : NIOCore.NIOBinaryIntegerEncodingStrategy
  public mutating func readLengthPrefixedSlice<Strategy>(strategy: Strategy) -> NIOCore.ByteBuffer? where Strategy : NIOCore.NIOBinaryIntegerEncodingStrategy
}
extension NIOCore.ByteBuffer {
  @discardableResult
  public mutating func writeLengthPrefixedBuffer<Strategy>(_ buffer: NIOCore.ByteBuffer, strategy: Strategy) -> Swift.Int where Strategy : NIOCore.NIOBinaryIntegerEncodingStrategy
  @discardableResult
  public mutating func writeLengthPrefixedString<Strategy>(_ string: Swift.String, strategy: Strategy) -> Swift.Int where Strategy : NIOCore.NIOBinaryIntegerEncodingStrategy
  @discardableResult
  public mutating func writeLengthPrefixedBytes<Bytes, Strategy>(_ bytes: Bytes, strategy: Strategy) -> Swift.Int where Bytes : Swift.Sequence, Strategy : NIOCore.NIOBinaryIntegerEncodingStrategy, Bytes.Element == Swift.UInt8
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(buffer: NIOCore.ByteBuffer)
}
extension Swift.String {
  public init(buffer: NIOCore.ByteBuffer)
}
extension Dispatch.DispatchData {
  public init(buffer: NIOCore.ByteBuffer)
}
public struct ByteBufferAllocator : Swift.Sendable {
  public init()
  public func buffer(capacity: Swift.Int) -> NIOCore.ByteBuffer
}
public struct ByteBuffer {
  public typealias _Index = Swift.UInt32
  public typealias _Capacity = Swift.UInt32
  public var writableBytes: Swift.Int {
    get
  }
  public var readableBytes: Swift.Int {
    get
  }
  public var capacity: Swift.Int {
    get
  }
  public var storageCapacity: Swift.Int {
    get
  }
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
  public mutating func reserveCapacity(minimumWritableBytes: Swift.Int)
  public mutating func withUnsafeMutableReadableBytes<T>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> T) rethrows -> T
  public mutating func withUnsafeMutableWritableBytes<T>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> T) rethrows -> T
  @discardableResult
  public mutating func writeWithUnsafeMutableBytes(minimumWritableBytes: Swift.Int, _ body: (Swift.UnsafeMutableRawBufferPointer) throws -> Swift.Int) rethrows -> Swift.Int
  @available(*, deprecated, message: "please use writeWithUnsafeMutableBytes(minimumWritableBytes:_:) instead to ensure sufficient write capacity.")
  @discardableResult
  public mutating func writeWithUnsafeMutableBytes(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> Swift.Int) rethrows -> Swift.Int
  public func withVeryUnsafeBytes<T>(_ body: (Swift.UnsafeRawBufferPointer) throws -> T) rethrows -> T
  public mutating func withVeryUnsafeMutableBytes<T>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> T) rethrows -> T
  public func withUnsafeReadableBytes<T>(_ body: (Swift.UnsafeRawBufferPointer) throws -> T) rethrows -> T
  public func withUnsafeReadableBytesWithStorageManagement<T>(_ body: (Swift.UnsafeRawBufferPointer, Swift.Unmanaged<Swift.AnyObject>) throws -> T) rethrows -> T
  public func withVeryUnsafeBytesWithStorageManagement<T>(_ body: (Swift.UnsafeRawBufferPointer, Swift.Unmanaged<Swift.AnyObject>) throws -> T) rethrows -> T
  public func getSlice(at index: Swift.Int, length: Swift.Int) -> NIOCore.ByteBuffer?
  public func peekSlice(length: Swift.Int) -> NIOCore.ByteBuffer?
  @discardableResult
  public mutating func discardReadBytes() -> Swift.Bool
  @discardableResult
  public mutating func shrinkBufferCapacity(to desiredCapacity: Swift.Int) -> Swift.Bool
  public var readerIndex: Swift.Int {
    get
  }
  public var writerIndex: Swift.Int {
    get
  }
  public mutating func clear()
  @available(*, deprecated, message: "Use an `Int` as the argument")
  public mutating func clear(minimumCapacity: Swift.UInt32)
  public mutating func clear(minimumCapacity: Swift.Int)
}
extension NIOCore.ByteBuffer : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension NIOCore.ByteBuffer {
  @discardableResult
  public mutating func setBytes<Bytes>(_ bytes: Bytes, at index: Swift.Int) -> Swift.Int where Bytes : Swift.Sequence, Bytes.Element == Swift.UInt8
  @discardableResult
  public mutating func setBytes(_ bytes: Swift.UnsafeRawBufferPointer, at index: Swift.Int) -> Swift.Int
  public mutating func moveReaderIndex(forwardBy offset: Swift.Int)
  public mutating func moveReaderIndex(to offset: Swift.Int)
  public mutating func moveWriterIndex(forwardBy offset: Swift.Int)
  public mutating func moveWriterIndex(to offset: Swift.Int)
}
extension NIOCore.ByteBuffer {
  @discardableResult
  public mutating func copyBytes(at fromIndex: Swift.Int, to toIndex: Swift.Int, length: Swift.Int) throws -> Swift.Int
  public struct CopyBytesError : Swift.Error {
    public static let negativeLength: NIOCore.ByteBuffer.CopyBytesError
    public static let unreadableSourceBytes: NIOCore.ByteBuffer.CopyBytesError
  }
}
extension NIOCore.ByteBuffer.CopyBytesError : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NIOCore.ByteBuffer.CopyBytesError, b: NIOCore.ByteBuffer.CopyBytesError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.ByteBuffer.CopyBytesError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NIOCore.ByteBuffer : Swift.Equatable {
  public static func == (lhs: NIOCore.ByteBuffer, rhs: NIOCore.ByteBuffer) -> Swift.Bool
}
extension NIOCore.ByteBuffer : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.ByteBuffer : @unchecked Swift.Sendable {
}
extension NIOCore.ByteBuffer {
  public mutating func modifyIfUniquelyOwned<T>(_ body: (inout NIOCore.ByteBuffer) throws -> T) rethrows -> T?
}
extension NIOCore.ByteBuffer {
  public init(plainHexEncodedBytes string: Swift.String) throws
  public struct HexDumpFormat : Swift.Hashable, Swift.Sendable {
    public static let plain: NIOCore.ByteBuffer.HexDumpFormat
    public static let detailed: NIOCore.ByteBuffer.HexDumpFormat
    public static let compact: NIOCore.ByteBuffer.HexDumpFormat
    public static func plain(maxBytes: Swift.Int) -> NIOCore.ByteBuffer.HexDumpFormat
    public static func detailed(maxBytes: Swift.Int) -> NIOCore.ByteBuffer.HexDumpFormat
    public static func compact(maxBytes: Swift.Int) -> NIOCore.ByteBuffer.HexDumpFormat
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NIOCore.ByteBuffer.HexDumpFormat, b: NIOCore.ByteBuffer.HexDumpFormat) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hexDump(format: NIOCore.ByteBuffer.HexDumpFormat) -> Swift.String
  public struct HexDecodingError : Swift.Error, Swift.Equatable {
    public static let invalidHexLength: NIOCore.ByteBuffer.HexDecodingError
    public static let invalidCharacter: NIOCore.ByteBuffer.HexDecodingError
    public static func == (a: NIOCore.ByteBuffer.HexDecodingError, b: NIOCore.ByteBuffer.HexDecodingError) -> Swift.Bool
  }
}
extension NIOCore.ByteBuffer {
  public mutating func readInteger<T>(endianness: NIOCore.Endianness = .big, as: T.Type = T.self) -> T? where T : Swift.FixedWidthInteger
  public func getInteger<T>(at index: Swift.Int, endianness: NIOCore.Endianness = Endianness.big, as: T.Type = T.self) -> T? where T : Swift.FixedWidthInteger
  @discardableResult
  public mutating func writeInteger<T>(_ integer: T, endianness: NIOCore.Endianness = .big, as: T.Type = T.self) -> Swift.Int where T : Swift.FixedWidthInteger
  @discardableResult
  public mutating func setInteger<T>(_ integer: T, at index: Swift.Int, endianness: NIOCore.Endianness = .big, as: T.Type = T.self) -> Swift.Int where T : Swift.FixedWidthInteger
  public func peekInteger<T>(endianness: NIOCore.Endianness = .big, as: T.Type = T.self) -> T? where T : Swift.FixedWidthInteger
}
extension Swift.FixedWidthInteger {
  public init?(buffer: NIOCore.ByteBuffer, endianness: NIOCore.Endianness = .host)
}
public enum Endianness : Swift.Sendable {
  public static let host: NIOCore.Endianness
  case big
  case little
  public static func == (a: NIOCore.Endianness, b: NIOCore.Endianness) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.ByteBuffer {
  public struct LengthPrefixError : Swift.Error {
    public static let messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat: NIOCore.ByteBuffer.LengthPrefixError
    public static let messageCouldNotBeReadSuccessfully: NIOCore.ByteBuffer.LengthPrefixError
  }
}
extension NIOCore.ByteBuffer {
  @discardableResult
  public mutating func writeLengthPrefixed<Integer>(endianness: NIOCore.Endianness = .big, as integer: Integer.Type, writeMessage: (inout NIOCore.ByteBuffer) throws -> Swift.Int) throws -> Swift.Int where Integer : Swift.FixedWidthInteger
}
extension NIOCore.ByteBuffer {
  public mutating func readLengthPrefixed<Integer, Result>(endianness: NIOCore.Endianness = .big, as integer: Integer.Type, readMessage: (NIOCore.ByteBuffer) throws -> Result?) throws -> Result? where Integer : Swift.FixedWidthInteger
  public mutating func readLengthPrefixedSlice<Integer>(endianness: NIOCore.Endianness = .big, as integer: Integer.Type) -> NIOCore.ByteBuffer? where Integer : Swift.FixedWidthInteger
  public func getLengthPrefixedSlice<Integer>(at index: Swift.Int, endianness: NIOCore.Endianness = .big, as integer: Integer.Type) -> NIOCore.ByteBuffer? where Integer : Swift.FixedWidthInteger
  public func peekLengthPrefixedSlice<Integer>(endianness: NIOCore.Endianness = .big, as integer: Integer.Type) -> NIOCore.ByteBuffer? where Integer : Swift.FixedWidthInteger
}
extension NIOCore.ByteBuffer {
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2>(endianness: NIOCore.Endianness = .big, as: (T1, T2).Type = (T1, T2).self) -> (T1, T2)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (T1(bigEndian: v1), T2(bigEndian: v2))
        case .little:
            return (T1(littleEndian: v1), T2(littleEndian: v2))
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2>(endianness: NIOCore.Endianness = .big, as: (T1, T2).Type = (T1, T2).self) -> (T1, T2)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2>(_ value1: T1, _ value2: T2, endianness: NIOCore.Endianness = .big, as: (T1, T2).Type = (T1, T2).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3).Type = (T1, T2, T3).self) -> (T1, T2, T3)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3))
        case .little:
            return (T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3))
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3).Type = (T1, T2, T3).self) -> (T1, T2, T3)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3>(_ value1: T1, _ value2: T2, _ value3: T3, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3).Type = (T1, T2, T3).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4).Type = (T1, T2, T3, T4).self) -> (T1, T2, T3, T4)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4))
        case .little:
            return (T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4))
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4).Type = (T1, T2, T3, T4).self) -> (T1, T2, T3, T4)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4).Type = (T1, T2, T3, T4).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5).Type = (T1, T2, T3, T4, T5).self) -> (T1, T2, T3, T4, T5)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5))
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5).Type = (T1, T2, T3, T4, T5).self) -> (T1, T2, T3, T4, T5)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5).Type = (T1, T2, T3, T4, T5).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6).Type = (T1, T2, T3, T4, T5, T6).self) -> (T1, T2, T3, T4, T5, T6)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6).Type = (T1, T2, T3, T4, T5, T6).self) -> (T1, T2, T3, T4, T5, T6)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6).Type = (T1, T2, T3, T4, T5, T6).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7).Type = (T1, T2, T3, T4, T5, T6, T7).self) -> (T1, T2, T3, T4, T5, T6, T7)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7).Type = (T1, T2, T3, T4, T5, T6, T7).self) -> (T1, T2, T3, T4, T5, T6, T7)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7).Type = (T1, T2, T3, T4, T5, T6, T7).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8).Type = (T1, T2, T3, T4, T5, T6, T7, T8).self) -> (T1, T2, T3, T4, T5, T6, T7, T8)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8).Type = (T1, T2, T3, T4, T5, T6, T7, T8).self) -> (T1, T2, T3, T4, T5, T6, T7, T8)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8).Type = (T1, T2, T3, T4, T5, T6, T7, T8).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size
        bytesRequired &+= MemoryLayout<T9>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var v9: T9 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            withUnsafeMutableBytes(of: &v9) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T9>.size)
            }
            offset = offset &+ MemoryLayout<T9>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8), T9(bigEndian: v9)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8),
                T9(littleEndian: v9)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, _ value9: T9, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        var v9: T9
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
            v9 = value9.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
            v9 = value9.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size
        spaceNeeded &+= MemoryLayout<T9>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            (basePtr + offset).copyMemory(from: &v9, byteCount: MemoryLayout<T9>.size)
            offset = offset &+ MemoryLayout<T9>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size
        bytesRequired &+= MemoryLayout<T9>.size
        bytesRequired &+= MemoryLayout<T10>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var v9: T9 = 0
        var v10: T10 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            withUnsafeMutableBytes(of: &v9) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T9>.size)
            }
            offset = offset &+ MemoryLayout<T9>.size
            withUnsafeMutableBytes(of: &v10) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T10>.size)
            }
            offset = offset &+ MemoryLayout<T10>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8), T9(bigEndian: v9), T10(bigEndian: v10)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8),
                T9(littleEndian: v9), T10(littleEndian: v10)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, _ value9: T9, _ value10: T10, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        var v9: T9
        var v10: T10
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
            v9 = value9.bigEndian
            v10 = value10.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
            v9 = value9.littleEndian
            v10 = value10.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size
        spaceNeeded &+= MemoryLayout<T9>.size
        spaceNeeded &+= MemoryLayout<T10>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            (basePtr + offset).copyMemory(from: &v9, byteCount: MemoryLayout<T9>.size)
            offset = offset &+ MemoryLayout<T9>.size
            (basePtr + offset).copyMemory(from: &v10, byteCount: MemoryLayout<T10>.size)
            offset = offset &+ MemoryLayout<T10>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size
        bytesRequired &+= MemoryLayout<T9>.size
        bytesRequired &+= MemoryLayout<T10>.size
        bytesRequired &+= MemoryLayout<T11>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var v9: T9 = 0
        var v10: T10 = 0
        var v11: T11 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            withUnsafeMutableBytes(of: &v9) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T9>.size)
            }
            offset = offset &+ MemoryLayout<T9>.size
            withUnsafeMutableBytes(of: &v10) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T10>.size)
            }
            offset = offset &+ MemoryLayout<T10>.size
            withUnsafeMutableBytes(of: &v11) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T11>.size)
            }
            offset = offset &+ MemoryLayout<T11>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8), T9(bigEndian: v9), T10(bigEndian: v10),
                T11(bigEndian: v11)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8),
                T9(littleEndian: v9), T10(littleEndian: v10), T11(littleEndian: v11)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, _ value9: T9, _ value10: T10, _ value11: T11, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        var v9: T9
        var v10: T10
        var v11: T11
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
            v9 = value9.bigEndian
            v10 = value10.bigEndian
            v11 = value11.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
            v9 = value9.littleEndian
            v10 = value10.littleEndian
            v11 = value11.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size
        spaceNeeded &+= MemoryLayout<T9>.size
        spaceNeeded &+= MemoryLayout<T10>.size
        spaceNeeded &+= MemoryLayout<T11>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            (basePtr + offset).copyMemory(from: &v9, byteCount: MemoryLayout<T9>.size)
            offset = offset &+ MemoryLayout<T9>.size
            (basePtr + offset).copyMemory(from: &v10, byteCount: MemoryLayout<T10>.size)
            offset = offset &+ MemoryLayout<T10>.size
            (basePtr + offset).copyMemory(from: &v11, byteCount: MemoryLayout<T11>.size)
            offset = offset &+ MemoryLayout<T11>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size
        bytesRequired &+= MemoryLayout<T9>.size
        bytesRequired &+= MemoryLayout<T10>.size
        bytesRequired &+= MemoryLayout<T11>.size
        bytesRequired &+= MemoryLayout<T12>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var v9: T9 = 0
        var v10: T10 = 0
        var v11: T11 = 0
        var v12: T12 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            withUnsafeMutableBytes(of: &v9) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T9>.size)
            }
            offset = offset &+ MemoryLayout<T9>.size
            withUnsafeMutableBytes(of: &v10) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T10>.size)
            }
            offset = offset &+ MemoryLayout<T10>.size
            withUnsafeMutableBytes(of: &v11) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T11>.size)
            }
            offset = offset &+ MemoryLayout<T11>.size
            withUnsafeMutableBytes(of: &v12) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T12>.size)
            }
            offset = offset &+ MemoryLayout<T12>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8), T9(bigEndian: v9), T10(bigEndian: v10),
                T11(bigEndian: v11), T12(bigEndian: v12)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8),
                T9(littleEndian: v9), T10(littleEndian: v10), T11(littleEndian: v11), T12(littleEndian: v12)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, _ value9: T9, _ value10: T10, _ value11: T11, _ value12: T12, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12
        ).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        var v9: T9
        var v10: T10
        var v11: T11
        var v12: T12
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
            v9 = value9.bigEndian
            v10 = value10.bigEndian
            v11 = value11.bigEndian
            v12 = value12.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
            v9 = value9.littleEndian
            v10 = value10.littleEndian
            v11 = value11.littleEndian
            v12 = value12.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size
        spaceNeeded &+= MemoryLayout<T9>.size
        spaceNeeded &+= MemoryLayout<T10>.size
        spaceNeeded &+= MemoryLayout<T11>.size
        spaceNeeded &+= MemoryLayout<T12>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            (basePtr + offset).copyMemory(from: &v9, byteCount: MemoryLayout<T9>.size)
            offset = offset &+ MemoryLayout<T9>.size
            (basePtr + offset).copyMemory(from: &v10, byteCount: MemoryLayout<T10>.size)
            offset = offset &+ MemoryLayout<T10>.size
            (basePtr + offset).copyMemory(from: &v11, byteCount: MemoryLayout<T11>.size)
            offset = offset &+ MemoryLayout<T11>.size
            (basePtr + offset).copyMemory(from: &v12, byteCount: MemoryLayout<T12>.size)
            offset = offset &+ MemoryLayout<T12>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size
        bytesRequired &+= MemoryLayout<T9>.size
        bytesRequired &+= MemoryLayout<T10>.size
        bytesRequired &+= MemoryLayout<T11>.size
        bytesRequired &+= MemoryLayout<T12>.size
        bytesRequired &+= MemoryLayout<T13>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var v9: T9 = 0
        var v10: T10 = 0
        var v11: T11 = 0
        var v12: T12 = 0
        var v13: T13 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            withUnsafeMutableBytes(of: &v9) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T9>.size)
            }
            offset = offset &+ MemoryLayout<T9>.size
            withUnsafeMutableBytes(of: &v10) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T10>.size)
            }
            offset = offset &+ MemoryLayout<T10>.size
            withUnsafeMutableBytes(of: &v11) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T11>.size)
            }
            offset = offset &+ MemoryLayout<T11>.size
            withUnsafeMutableBytes(of: &v12) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T12>.size)
            }
            offset = offset &+ MemoryLayout<T12>.size
            withUnsafeMutableBytes(of: &v13) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T13>.size)
            }
            offset = offset &+ MemoryLayout<T13>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8), T9(bigEndian: v9), T10(bigEndian: v10),
                T11(bigEndian: v11), T12(bigEndian: v12), T13(bigEndian: v13)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8),
                T9(littleEndian: v9), T10(littleEndian: v10), T11(littleEndian: v11), T12(littleEndian: v12),
                T13(littleEndian: v13)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, _ value9: T9, _ value10: T10, _ value11: T11, _ value12: T12, _ value13: T13, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13
        ).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        var v9: T9
        var v10: T10
        var v11: T11
        var v12: T12
        var v13: T13
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
            v9 = value9.bigEndian
            v10 = value10.bigEndian
            v11 = value11.bigEndian
            v12 = value12.bigEndian
            v13 = value13.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
            v9 = value9.littleEndian
            v10 = value10.littleEndian
            v11 = value11.littleEndian
            v12 = value12.littleEndian
            v13 = value13.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size
        spaceNeeded &+= MemoryLayout<T9>.size
        spaceNeeded &+= MemoryLayout<T10>.size
        spaceNeeded &+= MemoryLayout<T11>.size
        spaceNeeded &+= MemoryLayout<T12>.size
        spaceNeeded &+= MemoryLayout<T13>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            (basePtr + offset).copyMemory(from: &v9, byteCount: MemoryLayout<T9>.size)
            offset = offset &+ MemoryLayout<T9>.size
            (basePtr + offset).copyMemory(from: &v10, byteCount: MemoryLayout<T10>.size)
            offset = offset &+ MemoryLayout<T10>.size
            (basePtr + offset).copyMemory(from: &v11, byteCount: MemoryLayout<T11>.size)
            offset = offset &+ MemoryLayout<T11>.size
            (basePtr + offset).copyMemory(from: &v12, byteCount: MemoryLayout<T12>.size)
            offset = offset &+ MemoryLayout<T12>.size
            (basePtr + offset).copyMemory(from: &v13, byteCount: MemoryLayout<T13>.size)
            offset = offset &+ MemoryLayout<T13>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger, T14 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size
        bytesRequired &+= MemoryLayout<T9>.size
        bytesRequired &+= MemoryLayout<T10>.size
        bytesRequired &+= MemoryLayout<T11>.size
        bytesRequired &+= MemoryLayout<T12>.size
        bytesRequired &+= MemoryLayout<T13>.size
        bytesRequired &+= MemoryLayout<T14>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var v9: T9 = 0
        var v10: T10 = 0
        var v11: T11 = 0
        var v12: T12 = 0
        var v13: T13 = 0
        var v14: T14 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            withUnsafeMutableBytes(of: &v9) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T9>.size)
            }
            offset = offset &+ MemoryLayout<T9>.size
            withUnsafeMutableBytes(of: &v10) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T10>.size)
            }
            offset = offset &+ MemoryLayout<T10>.size
            withUnsafeMutableBytes(of: &v11) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T11>.size)
            }
            offset = offset &+ MemoryLayout<T11>.size
            withUnsafeMutableBytes(of: &v12) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T12>.size)
            }
            offset = offset &+ MemoryLayout<T12>.size
            withUnsafeMutableBytes(of: &v13) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T13>.size)
            }
            offset = offset &+ MemoryLayout<T13>.size
            withUnsafeMutableBytes(of: &v14) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T14>.size)
            }
            offset = offset &+ MemoryLayout<T14>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8), T9(bigEndian: v9), T10(bigEndian: v10),
                T11(bigEndian: v11), T12(bigEndian: v12), T13(bigEndian: v13), T14(bigEndian: v14)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8),
                T9(littleEndian: v9), T10(littleEndian: v10), T11(littleEndian: v11), T12(littleEndian: v12),
                T13(littleEndian: v13), T14(littleEndian: v14)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger, T14 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, _ value9: T9, _ value10: T10, _ value11: T11, _ value12: T12, _ value13: T13, _ value14: T14, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14
        ).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger, T14 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        var v9: T9
        var v10: T10
        var v11: T11
        var v12: T12
        var v13: T13
        var v14: T14
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
            v9 = value9.bigEndian
            v10 = value10.bigEndian
            v11 = value11.bigEndian
            v12 = value12.bigEndian
            v13 = value13.bigEndian
            v14 = value14.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
            v9 = value9.littleEndian
            v10 = value10.littleEndian
            v11 = value11.littleEndian
            v12 = value12.littleEndian
            v13 = value13.littleEndian
            v14 = value14.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size
        spaceNeeded &+= MemoryLayout<T9>.size
        spaceNeeded &+= MemoryLayout<T10>.size
        spaceNeeded &+= MemoryLayout<T11>.size
        spaceNeeded &+= MemoryLayout<T12>.size
        spaceNeeded &+= MemoryLayout<T13>.size
        spaceNeeded &+= MemoryLayout<T14>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            (basePtr + offset).copyMemory(from: &v9, byteCount: MemoryLayout<T9>.size)
            offset = offset &+ MemoryLayout<T9>.size
            (basePtr + offset).copyMemory(from: &v10, byteCount: MemoryLayout<T10>.size)
            offset = offset &+ MemoryLayout<T10>.size
            (basePtr + offset).copyMemory(from: &v11, byteCount: MemoryLayout<T11>.size)
            offset = offset &+ MemoryLayout<T11>.size
            (basePtr + offset).copyMemory(from: &v12, byteCount: MemoryLayout<T12>.size)
            offset = offset &+ MemoryLayout<T12>.size
            (basePtr + offset).copyMemory(from: &v13, byteCount: MemoryLayout<T13>.size)
            offset = offset &+ MemoryLayout<T13>.size
            (basePtr + offset).copyMemory(from: &v14, byteCount: MemoryLayout<T14>.size)
            offset = offset &+ MemoryLayout<T14>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
  @_alwaysEmitIntoClient public mutating func readMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger, T14 : Swift.FixedWidthInteger, T15 : Swift.FixedWidthInteger {
        var bytesRequired: Int = MemoryLayout<T1>.size
        bytesRequired &+= MemoryLayout<T2>.size
        bytesRequired &+= MemoryLayout<T3>.size
        bytesRequired &+= MemoryLayout<T4>.size
        bytesRequired &+= MemoryLayout<T5>.size
        bytesRequired &+= MemoryLayout<T6>.size
        bytesRequired &+= MemoryLayout<T7>.size
        bytesRequired &+= MemoryLayout<T8>.size
        bytesRequired &+= MemoryLayout<T9>.size
        bytesRequired &+= MemoryLayout<T10>.size
        bytesRequired &+= MemoryLayout<T11>.size
        bytesRequired &+= MemoryLayout<T12>.size
        bytesRequired &+= MemoryLayout<T13>.size
        bytesRequired &+= MemoryLayout<T14>.size
        bytesRequired &+= MemoryLayout<T15>.size

        guard self.readableBytes >= bytesRequired else {
            return nil
        }

        var v1: T1 = 0
        var v2: T2 = 0
        var v3: T3 = 0
        var v4: T4 = 0
        var v5: T5 = 0
        var v6: T6 = 0
        var v7: T7 = 0
        var v8: T8 = 0
        var v9: T9 = 0
        var v10: T10 = 0
        var v11: T11 = 0
        var v12: T12 = 0
        var v13: T13 = 0
        var v14: T14 = 0
        var v15: T15 = 0
        var offset = 0
        self.readWithUnsafeReadableBytes { ptr -> Int in
            assert(ptr.count >= bytesRequired)
            let basePtr = ptr.baseAddress!   
            withUnsafeMutableBytes(of: &v1) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T1>.size)
            }
            offset = offset &+ MemoryLayout<T1>.size
            withUnsafeMutableBytes(of: &v2) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T2>.size)
            }
            offset = offset &+ MemoryLayout<T2>.size
            withUnsafeMutableBytes(of: &v3) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T3>.size)
            }
            offset = offset &+ MemoryLayout<T3>.size
            withUnsafeMutableBytes(of: &v4) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T4>.size)
            }
            offset = offset &+ MemoryLayout<T4>.size
            withUnsafeMutableBytes(of: &v5) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T5>.size)
            }
            offset = offset &+ MemoryLayout<T5>.size
            withUnsafeMutableBytes(of: &v6) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T6>.size)
            }
            offset = offset &+ MemoryLayout<T6>.size
            withUnsafeMutableBytes(of: &v7) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T7>.size)
            }
            offset = offset &+ MemoryLayout<T7>.size
            withUnsafeMutableBytes(of: &v8) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T8>.size)
            }
            offset = offset &+ MemoryLayout<T8>.size
            withUnsafeMutableBytes(of: &v9) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T9>.size)
            }
            offset = offset &+ MemoryLayout<T9>.size
            withUnsafeMutableBytes(of: &v10) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T10>.size)
            }
            offset = offset &+ MemoryLayout<T10>.size
            withUnsafeMutableBytes(of: &v11) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T11>.size)
            }
            offset = offset &+ MemoryLayout<T11>.size
            withUnsafeMutableBytes(of: &v12) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T12>.size)
            }
            offset = offset &+ MemoryLayout<T12>.size
            withUnsafeMutableBytes(of: &v13) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T13>.size)
            }
            offset = offset &+ MemoryLayout<T13>.size
            withUnsafeMutableBytes(of: &v14) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T14>.size)
            }
            offset = offset &+ MemoryLayout<T14>.size
            withUnsafeMutableBytes(of: &v15) { destPtr in
                destPtr.baseAddress!.copyMemory(from: basePtr + offset, byteCount: MemoryLayout<T15>.size)
            }
            offset = offset &+ MemoryLayout<T15>.size
            assert(offset == bytesRequired)
            return offset
        }
        switch endianness {
        case .big:
            return (
                T1(bigEndian: v1), T2(bigEndian: v2), T3(bigEndian: v3), T4(bigEndian: v4), T5(bigEndian: v5),
                T6(bigEndian: v6), T7(bigEndian: v7), T8(bigEndian: v8), T9(bigEndian: v9), T10(bigEndian: v10),
                T11(bigEndian: v11), T12(bigEndian: v12), T13(bigEndian: v13), T14(bigEndian: v14), T15(bigEndian: v15)
            )
        case .little:
            return (
                T1(littleEndian: v1), T2(littleEndian: v2), T3(littleEndian: v3), T4(littleEndian: v4),
                T5(littleEndian: v5), T6(littleEndian: v6), T7(littleEndian: v7), T8(littleEndian: v8),
                T9(littleEndian: v9), T10(littleEndian: v10), T11(littleEndian: v11), T12(littleEndian: v12),
                T13(littleEndian: v13), T14(littleEndian: v14), T15(littleEndian: v15)
            )
        }
    }
  @_alwaysEmitIntoClient public func peekMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15
        ).self) -> (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)? where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger, T14 : Swift.FixedWidthInteger, T15 : Swift.FixedWidthInteger {
        var copy = self
        return copy.readMultipleIntegers(endianness: endianness, as: `as`)
    }
  @discardableResult
  @_alwaysEmitIntoClient public mutating func writeMultipleIntegers<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(_ value1: T1, _ value2: T2, _ value3: T3, _ value4: T4, _ value5: T5, _ value6: T6, _ value7: T7, _ value8: T8, _ value9: T9, _ value10: T10, _ value11: T11, _ value12: T12, _ value13: T13, _ value14: T14, _ value15: T15, endianness: NIOCore.Endianness = .big, as: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15).Type = (
            T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15
        ).self) -> Swift.Int where T1 : Swift.FixedWidthInteger, T2 : Swift.FixedWidthInteger, T3 : Swift.FixedWidthInteger, T4 : Swift.FixedWidthInteger, T5 : Swift.FixedWidthInteger, T6 : Swift.FixedWidthInteger, T7 : Swift.FixedWidthInteger, T8 : Swift.FixedWidthInteger, T9 : Swift.FixedWidthInteger, T10 : Swift.FixedWidthInteger, T11 : Swift.FixedWidthInteger, T12 : Swift.FixedWidthInteger, T13 : Swift.FixedWidthInteger, T14 : Swift.FixedWidthInteger, T15 : Swift.FixedWidthInteger {
        var v1: T1
        var v2: T2
        var v3: T3
        var v4: T4
        var v5: T5
        var v6: T6
        var v7: T7
        var v8: T8
        var v9: T9
        var v10: T10
        var v11: T11
        var v12: T12
        var v13: T13
        var v14: T14
        var v15: T15
        switch endianness {
        case .big:
            v1 = value1.bigEndian
            v2 = value2.bigEndian
            v3 = value3.bigEndian
            v4 = value4.bigEndian
            v5 = value5.bigEndian
            v6 = value6.bigEndian
            v7 = value7.bigEndian
            v8 = value8.bigEndian
            v9 = value9.bigEndian
            v10 = value10.bigEndian
            v11 = value11.bigEndian
            v12 = value12.bigEndian
            v13 = value13.bigEndian
            v14 = value14.bigEndian
            v15 = value15.bigEndian
        case .little:
            v1 = value1.littleEndian
            v2 = value2.littleEndian
            v3 = value3.littleEndian
            v4 = value4.littleEndian
            v5 = value5.littleEndian
            v6 = value6.littleEndian
            v7 = value7.littleEndian
            v8 = value8.littleEndian
            v9 = value9.littleEndian
            v10 = value10.littleEndian
            v11 = value11.littleEndian
            v12 = value12.littleEndian
            v13 = value13.littleEndian
            v14 = value14.littleEndian
            v15 = value15.littleEndian
        }

        var spaceNeeded: Int = MemoryLayout<T1>.size
        spaceNeeded &+= MemoryLayout<T2>.size
        spaceNeeded &+= MemoryLayout<T3>.size
        spaceNeeded &+= MemoryLayout<T4>.size
        spaceNeeded &+= MemoryLayout<T5>.size
        spaceNeeded &+= MemoryLayout<T6>.size
        spaceNeeded &+= MemoryLayout<T7>.size
        spaceNeeded &+= MemoryLayout<T8>.size
        spaceNeeded &+= MemoryLayout<T9>.size
        spaceNeeded &+= MemoryLayout<T10>.size
        spaceNeeded &+= MemoryLayout<T11>.size
        spaceNeeded &+= MemoryLayout<T12>.size
        spaceNeeded &+= MemoryLayout<T13>.size
        spaceNeeded &+= MemoryLayout<T14>.size
        spaceNeeded &+= MemoryLayout<T15>.size

        return self.writeWithUnsafeMutableBytes(minimumWritableBytes: spaceNeeded) { ptr -> Int in
            assert(ptr.count >= spaceNeeded)
            var offset = 0
            let basePtr = ptr.baseAddress!   
            (basePtr + offset).copyMemory(from: &v1, byteCount: MemoryLayout<T1>.size)
            offset = offset &+ MemoryLayout<T1>.size
            (basePtr + offset).copyMemory(from: &v2, byteCount: MemoryLayout<T2>.size)
            offset = offset &+ MemoryLayout<T2>.size
            (basePtr + offset).copyMemory(from: &v3, byteCount: MemoryLayout<T3>.size)
            offset = offset &+ MemoryLayout<T3>.size
            (basePtr + offset).copyMemory(from: &v4, byteCount: MemoryLayout<T4>.size)
            offset = offset &+ MemoryLayout<T4>.size
            (basePtr + offset).copyMemory(from: &v5, byteCount: MemoryLayout<T5>.size)
            offset = offset &+ MemoryLayout<T5>.size
            (basePtr + offset).copyMemory(from: &v6, byteCount: MemoryLayout<T6>.size)
            offset = offset &+ MemoryLayout<T6>.size
            (basePtr + offset).copyMemory(from: &v7, byteCount: MemoryLayout<T7>.size)
            offset = offset &+ MemoryLayout<T7>.size
            (basePtr + offset).copyMemory(from: &v8, byteCount: MemoryLayout<T8>.size)
            offset = offset &+ MemoryLayout<T8>.size
            (basePtr + offset).copyMemory(from: &v9, byteCount: MemoryLayout<T9>.size)
            offset = offset &+ MemoryLayout<T9>.size
            (basePtr + offset).copyMemory(from: &v10, byteCount: MemoryLayout<T10>.size)
            offset = offset &+ MemoryLayout<T10>.size
            (basePtr + offset).copyMemory(from: &v11, byteCount: MemoryLayout<T11>.size)
            offset = offset &+ MemoryLayout<T11>.size
            (basePtr + offset).copyMemory(from: &v12, byteCount: MemoryLayout<T12>.size)
            offset = offset &+ MemoryLayout<T12>.size
            (basePtr + offset).copyMemory(from: &v13, byteCount: MemoryLayout<T13>.size)
            offset = offset &+ MemoryLayout<T13>.size
            (basePtr + offset).copyMemory(from: &v14, byteCount: MemoryLayout<T14>.size)
            offset = offset &+ MemoryLayout<T14>.size
            (basePtr + offset).copyMemory(from: &v15, byteCount: MemoryLayout<T15>.size)
            offset = offset &+ MemoryLayout<T15>.size
            assert(offset == spaceNeeded)
            return offset
        }
    }
}
extension NIOCore.ByteBuffer {
  public struct QUICBinaryEncodingStrategy : NIOCore.NIOBinaryIntegerEncodingStrategy {
    public enum IntegerLength : Swift.Int, Swift.Sendable {
      case one
      case two
      case four
      case eight
      public init?(rawValue: Swift.Int)
      public typealias RawValue = Swift.Int
      public var rawValue: Swift.Int {
        get
      }
    }
    public var requiredBytesHint: Swift.Int
    public init(requiredBytesHint: NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength)
    public func readInteger<IntegerType>(as: IntegerType.Type, from buffer: inout NIOCore.ByteBuffer) -> IntegerType? where IntegerType : Swift.FixedWidthInteger
    public static func bytesNeededForInteger<IntegerType>(_ integer: IntegerType) -> Swift.Int where IntegerType : Swift.FixedWidthInteger
    public func writeInteger<IntegerType>(_ integer: IntegerType, to buffer: inout NIOCore.ByteBuffer) -> Swift.Int where IntegerType : Swift.FixedWidthInteger
    public func writeInteger<IntegerType>(_ integer: IntegerType, reservedCapacity: Swift.Int, to buffer: inout NIOCore.ByteBuffer) -> Swift.Int where IntegerType : Swift.FixedWidthInteger
  }
}
extension NIOCore.NIOBinaryIntegerEncodingStrategy where Self == NIOCore.ByteBuffer.QUICBinaryEncodingStrategy {
  public static func quic(requiredBytesHint: NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength) -> NIOCore.ByteBuffer.QUICBinaryEncodingStrategy
  public static var quic: NIOCore.ByteBuffer.QUICBinaryEncodingStrategy {
    get
  }
}
public struct ByteBufferView : Swift.RandomAccessCollection, Swift.Sendable {
  public typealias Element = Swift.UInt8
  public typealias Index = Swift.Int
  public typealias SubSequence = NIOCore.ByteBufferView
  public init(_ buffer: NIOCore.ByteBuffer)
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public var startIndex: NIOCore.ByteBufferView.Index {
    get
  }
  public var endIndex: NIOCore.ByteBufferView.Index {
    get
  }
  public func index(after i: NIOCore.ByteBufferView.Index) -> NIOCore.ByteBufferView.Index
  public var count: Swift.Int {
    get
  }
  public subscript(position: NIOCore.ByteBufferView.Index) -> Swift.UInt8 {
    get
    set
  }
  public subscript(range: Swift.Range<NIOCore.ByteBufferView.Index>) -> NIOCore.ByteBufferView {
    get
    set
  }
  public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Swift.UInt8>) throws -> R) rethrows -> R?
  public func _customIndexOfEquatableElement(_ element: NIOCore.ByteBufferView.Element) -> NIOCore.ByteBufferView.Index??
  public func _customLastIndexOfEquatableElement(_ element: NIOCore.ByteBufferView.Element) -> NIOCore.ByteBufferView.Index??
  public func _customContainsEquatableElement(_ element: NIOCore.ByteBufferView.Element) -> Swift.Bool?
  public func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Swift.UInt8>) -> (Swift.IndexingIterator<NIOCore.ByteBufferView>, Swift.UnsafeMutableBufferPointer<Swift.UInt8>.Index)
  public func _failEarlyRangeCheck(_ index: NIOCore.ByteBufferView.Index, bounds: Swift.Range<NIOCore.ByteBufferView.Index>)
  public func _failEarlyRangeCheck(_ index: NIOCore.ByteBufferView.Index, bounds: Swift.ClosedRange<NIOCore.ByteBufferView.Index>)
  public func _failEarlyRangeCheck(_ range: Swift.Range<NIOCore.ByteBufferView.Index>, bounds: Swift.Range<NIOCore.ByteBufferView.Index>)
  public typealias Indices = Swift.Range<NIOCore.ByteBufferView.Index>
  public typealias Iterator = Swift.IndexingIterator<NIOCore.ByteBufferView>
}
extension NIOCore.ByteBufferView : Swift.MutableCollection {
}
extension NIOCore.ByteBufferView : Swift.RangeReplaceableCollection {
  public init()
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
  public mutating func append(_ byte: Swift.UInt8)
  public mutating func append<Bytes>(contentsOf bytes: Bytes) where Bytes : Swift.Sequence, Bytes.Element == Swift.UInt8
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<NIOCore.ByteBufferView.Index>, with newElements: C) where C : Swift.Collection, C.Element == Swift.UInt8
}
extension NIOCore.ByteBuffer {
  public var readableBytesView: NIOCore.ByteBufferView {
    get
  }
  public func viewBytes(at index: Swift.Int, length: Swift.Int) -> NIOCore.ByteBufferView?
  public init(_ view: NIOCore.ByteBufferView)
}
extension NIOCore.ByteBufferView : Swift.Equatable {
  public static func == (lhs: NIOCore.ByteBufferView, rhs: NIOCore.ByteBufferView) -> Swift.Bool
}
extension NIOCore.ByteBufferView : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.ByteBufferView : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: NIOCore.ByteBufferView.Element...)
  public typealias ArrayLiteralElement = NIOCore.ByteBufferView.Element
}
public protocol ChannelCore : AnyObject {
  func localAddress0() throws -> NIOCore.SocketAddress
  func remoteAddress0() throws -> NIOCore.SocketAddress
  func register0(promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func registerAlreadyConfigured0(promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func bind0(to: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func connect0(to: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func write0(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func flush0()
  func read0()
  func close0(error: any Swift.Error, mode: NIOCore.CloseMode, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func triggerUserOutboundEvent0(_ event: Any, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func channelRead0(_ data: NIOCore.NIOAny)
  func errorCaught0(error: any Swift.Error)
}
public protocol Channel : AnyObject, NIOCore.ChannelOutboundInvoker, NIOCore._NIOPreconcurrencySendable {
  var allocator: NIOCore.ByteBufferAllocator { get }
  var closeFuture: NIOCore.EventLoopFuture<Swift.Void> { get }
  var pipeline: NIOCore.ChannelPipeline { get }
  var localAddress: NIOCore.SocketAddress? { get }
  var remoteAddress: NIOCore.SocketAddress? { get }
  var parent: (any NIOCore.Channel)? { get }
  func setOption<Option>(_ option: Option, value: Option.Value) -> NIOCore.EventLoopFuture<Swift.Void> where Option : NIOCore.ChannelOption
  func getOption<Option>(_ option: Option) -> NIOCore.EventLoopFuture<Option.Value> where Option : NIOCore.ChannelOption
  var isWritable: Swift.Bool { get }
  var isActive: Swift.Bool { get }
  var _channelCore: any NIOCore.ChannelCore { get }
  var syncOptions: (any NIOCore.NIOSynchronousChannelOptions)? { get }
  @preconcurrency func write<T>(_ any: T) -> NIOCore.EventLoopFuture<Swift.Void> where T : Swift.Sendable
  @preconcurrency func write<T>(_ any: T, promise: NIOCore.EventLoopPromise<Swift.Void>?) where T : Swift.Sendable
  @preconcurrency func writeAndFlush<T>(_ any: T) -> NIOCore.EventLoopFuture<Swift.Void> where T : Swift.Sendable
  @preconcurrency func writeAndFlush<T>(_ any: T, promise: NIOCore.EventLoopPromise<Swift.Void>?) where T : Swift.Sendable
}
extension NIOCore.Channel {
  public var syncOptions: (any NIOCore.NIOSynchronousChannelOptions)? {
    get
  }
}
public protocol NIOSynchronousChannelOptions {
  func setOption<Option>(_ option: Option, value: Option.Value) throws where Option : NIOCore.ChannelOption
  func getOption<Option>(_ option: Option) throws -> Option.Value where Option : NIOCore.ChannelOption
}
extension NIOCore.Channel {
  public func bind(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func connect(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  public func write(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func write<T>(_ data: T, promise: NIOCore.EventLoopPromise<Swift.Void>?) where T : Swift.Sendable
  public func flush()
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  public func writeAndFlush(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func writeAndFlush<T>(_ data: T, promise: NIOCore.EventLoopPromise<Swift.Void>?) where T : Swift.Sendable
  public func read()
  public func close(mode: NIOCore.CloseMode = .all, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func register(promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func registerAlreadyConfigured0(promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @preconcurrency public func triggerUserOutboundEvent(_ event: any Swift.Sendable, promise: NIOCore.EventLoopPromise<Swift.Void>?)
}
extension NIOCore.Channel {
  @preconcurrency public func write<T>(_ any: T) -> NIOCore.EventLoopFuture<Swift.Void> where T : Swift.Sendable
  @preconcurrency public func writeAndFlush<T>(_ any: T) -> NIOCore.EventLoopFuture<Swift.Void> where T : Swift.Sendable
}
extension NIOCore.ChannelCore {
  public func unwrapData<T>(_ data: NIOCore.NIOAny, as: T.Type = T.self) -> T
  public func tryUnwrapData<T>(_ data: NIOCore.NIOAny, as: T.Type = T.self) -> T?
  @available(*, deprecated, renamed: "removeHandlers(pipeline:)")
  public func removeHandlers(channel: any NIOCore.Channel)
  public func removeHandlers(pipeline: NIOCore.ChannelPipeline)
}
public enum ChannelError : Swift.Error {
  case connectPending
  case connectTimeout(NIOCore.TimeAmount)
  case operationUnsupported
  case ioOnClosedChannel
  case alreadyClosed
  case outputClosed
  case inputClosed
  case eof
  case writeMessageTooLarge
  case writeHostUnreachable
  case unknownLocalAddress
  case badMulticastGroupAddressFamily
  case badInterfaceAddressFamily
  case illegalMulticastAddress(NIOCore.SocketAddress)
  @available(*, deprecated, renamed: "NIOMulticastNotSupportedError")
  case multicastNotSupported(NIOCore.NIONetworkInterface)
  case inappropriateOperationForState
  case unremovableHandler
}
extension NIOCore.ChannelError : Swift.Equatable {
  public static func == (a: NIOCore.ChannelError, b: NIOCore.ChannelError) -> Swift.Bool
}
public struct NIOAttemptedToRemoveHandlerMultipleTimesError : Swift.Error {
}
public enum DatagramChannelError {
  public struct WriteOnUnconnectedSocketWithoutAddress : Swift.Error {
    public init()
  }
  public struct WriteOnConnectedSocketWithInvalidAddress : Swift.Error {
    public init(envelopeRemoteAddress: NIOCore.SocketAddress, connectedRemoteAddress: NIOCore.SocketAddress)
  }
}
public enum ChannelEvent : Swift.Equatable, Swift.Sendable {
  case inputClosed
  case outputClosed
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NIOCore.ChannelEvent, b: NIOCore.ChannelEvent) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ChannelShouldQuiesceEvent : Swift.Sendable {
  public init()
}
public protocol ChannelHandler : AnyObject {
  func handlerAdded(context: NIOCore.ChannelHandlerContext)
  func handlerRemoved(context: NIOCore.ChannelHandlerContext)
}
public protocol _ChannelOutboundHandler : NIOCore.ChannelHandler {
  func register(context: NIOCore.ChannelHandlerContext, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func bind(context: NIOCore.ChannelHandlerContext, to: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func connect(context: NIOCore.ChannelHandlerContext, to: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func write(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func flush(context: NIOCore.ChannelHandlerContext)
  func read(context: NIOCore.ChannelHandlerContext)
  func close(context: NIOCore.ChannelHandlerContext, mode: NIOCore.CloseMode, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func triggerUserOutboundEvent(context: NIOCore.ChannelHandlerContext, event: Any, promise: NIOCore.EventLoopPromise<Swift.Void>?)
}
public protocol _ChannelInboundHandler : NIOCore.ChannelHandler {
  func channelRegistered(context: NIOCore.ChannelHandlerContext)
  func channelUnregistered(context: NIOCore.ChannelHandlerContext)
  func channelActive(context: NIOCore.ChannelHandlerContext)
  func channelInactive(context: NIOCore.ChannelHandlerContext)
  func channelRead(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny)
  func channelReadComplete(context: NIOCore.ChannelHandlerContext)
  func channelWritabilityChanged(context: NIOCore.ChannelHandlerContext)
  func userInboundEventTriggered(context: NIOCore.ChannelHandlerContext, event: Any)
  func errorCaught(context: NIOCore.ChannelHandlerContext, error: any Swift.Error)
}
extension NIOCore.ChannelHandler {
  public func handlerAdded(context: NIOCore.ChannelHandlerContext)
  public func handlerRemoved(context: NIOCore.ChannelHandlerContext)
}
extension NIOCore._ChannelOutboundHandler {
  public func register(context: NIOCore.ChannelHandlerContext, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func bind(context: NIOCore.ChannelHandlerContext, to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func connect(context: NIOCore.ChannelHandlerContext, to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func write(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func flush(context: NIOCore.ChannelHandlerContext)
  public func read(context: NIOCore.ChannelHandlerContext)
  public func close(context: NIOCore.ChannelHandlerContext, mode: NIOCore.CloseMode, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func triggerUserOutboundEvent(context: NIOCore.ChannelHandlerContext, event: Any, promise: NIOCore.EventLoopPromise<Swift.Void>?)
}
extension NIOCore._ChannelInboundHandler {
  public func channelRegistered(context: NIOCore.ChannelHandlerContext)
  public func channelUnregistered(context: NIOCore.ChannelHandlerContext)
  public func channelActive(context: NIOCore.ChannelHandlerContext)
  public func channelInactive(context: NIOCore.ChannelHandlerContext)
  public func channelRead(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny)
  public func channelReadComplete(context: NIOCore.ChannelHandlerContext)
  public func channelWritabilityChanged(context: NIOCore.ChannelHandlerContext)
  public func userInboundEventTriggered(context: NIOCore.ChannelHandlerContext, event: Any)
  public func errorCaught(context: NIOCore.ChannelHandlerContext, error: any Swift.Error)
}
public protocol RemovableChannelHandler : NIOCore.ChannelHandler {
  func removeHandler(context: NIOCore.ChannelHandlerContext, removalToken: NIOCore.ChannelHandlerContext.RemovalToken)
}
extension NIOCore.RemovableChannelHandler {
  public func removeHandler(context: NIOCore.ChannelHandlerContext, removalToken: NIOCore.ChannelHandlerContext.RemovalToken)
}
public protocol NIOOutboundByteBufferingChannelHandler {
  var outboundBufferedBytes: Swift.Int { get }
}
public protocol NIOInboundByteBufferingChannelHandler {
  var inboundBufferedBytes: Swift.Int { get }
}
final public class AcceptBackoffHandler : NIOCore.ChannelDuplexHandler, NIOCore.RemovableChannelHandler {
  public typealias InboundIn = NIOCore.Channel
  public typealias OutboundIn = NIOCore.Channel
  public static func defaultBackoffProvider(error: NIOCore.IOError) -> NIOCore.TimeAmount?
  public init(backoffProvider: @escaping (NIOCore.IOError) -> NIOCore.TimeAmount? = AcceptBackoffHandler.defaultBackoffProvider)
  public init(shouldForwardIOErrorCaught: Swift.Bool, backoffProvider: @escaping (NIOCore.IOError) -> NIOCore.TimeAmount? = AcceptBackoffHandler.defaultBackoffProvider)
  final public func read(context: NIOCore.ChannelHandlerContext)
  final public func errorCaught(context: NIOCore.ChannelHandlerContext, error: any Swift.Error)
  final public func channelInactive(context: NIOCore.ChannelHandlerContext)
  final public func handlerRemoved(context: NIOCore.ChannelHandlerContext)
  public typealias InboundOut = Swift.Never
  public typealias OutboundOut = Swift.Never
  @objc deinit
}
@available(*, unavailable)
extension NIOCore.AcceptBackoffHandler : Swift.Sendable {
}
final public class BackPressureHandler : NIOCore.ChannelDuplexHandler, NIOCore.RemovableChannelHandler {
  public typealias OutboundIn = NIOCore.NIOAny
  public typealias InboundIn = NIOCore.ByteBuffer
  public typealias InboundOut = NIOCore.ByteBuffer
  public typealias OutboundOut = NIOCore.ByteBuffer
  public init()
  final public func read(context: NIOCore.ChannelHandlerContext)
  final public func channelWritabilityChanged(context: NIOCore.ChannelHandlerContext)
  final public func handlerRemoved(context: NIOCore.ChannelHandlerContext)
  @objc deinit
}
@available(*, unavailable)
extension NIOCore.BackPressureHandler : Swift.Sendable {
}
final public class IdleStateHandler : NIOCore.ChannelDuplexHandler, NIOCore.RemovableChannelHandler {
  public typealias InboundIn = NIOCore.NIOAny
  public typealias InboundOut = NIOCore.NIOAny
  public typealias OutboundIn = NIOCore.NIOAny
  public typealias OutboundOut = NIOCore.NIOAny
  public enum IdleStateEvent : Swift.Sendable {
    case write
    case read
    case all
    public static func == (a: NIOCore.IdleStateHandler.IdleStateEvent, b: NIOCore.IdleStateHandler.IdleStateEvent) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let readTimeout: NIOCore.TimeAmount?
  final public let writeTimeout: NIOCore.TimeAmount?
  final public let allTimeout: NIOCore.TimeAmount?
  public init(readTimeout: NIOCore.TimeAmount? = nil, writeTimeout: NIOCore.TimeAmount? = nil, allTimeout: NIOCore.TimeAmount? = nil)
  final public func handlerAdded(context: NIOCore.ChannelHandlerContext)
  final public func handlerRemoved(context: NIOCore.ChannelHandlerContext)
  final public func channelActive(context: NIOCore.ChannelHandlerContext)
  final public func channelRead(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny)
  final public func channelReadComplete(context: NIOCore.ChannelHandlerContext)
  final public func write(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @objc deinit
}
@available(*, unavailable)
extension NIOCore.IdleStateHandler : Swift.Sendable {
}
public protocol ChannelOutboundInvoker {
  func register(promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func bind(to: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func connect(to: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  func write(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func flush()
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  func writeAndFlush(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func read()
  func close(mode: NIOCore.CloseMode, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @preconcurrency func triggerUserOutboundEvent(_ event: any Swift.Sendable, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  var eventLoop: any NIOCore.EventLoop { get }
}
extension NIOCore.ChannelOutboundInvoker {
  public func register(file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  public func bind(to address: NIOCore.SocketAddress, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  public func connect(to address: NIOCore.SocketAddress, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  public func write(_ data: NIOCore.NIOAny, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  public func writeAndFlush(_ data: NIOCore.NIOAny, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  public func close(mode: NIOCore.CloseMode = .all, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  @preconcurrency public func triggerUserOutboundEvent(_ event: any Swift.Sendable, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
}
public protocol ChannelInboundInvoker {
  func fireChannelRegistered()
  func fireChannelUnregistered()
  func fireChannelActive()
  func fireChannelInactive()
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  func fireChannelRead(_ data: NIOCore.NIOAny)
  func fireChannelReadComplete()
  func fireChannelWritabilityChanged()
  func fireErrorCaught(_ error: any Swift.Error)
  @preconcurrency func fireUserInboundEventTriggered(_ event: any Swift.Sendable)
}
public protocol ChannelInvoker : NIOCore.ChannelInboundInvoker, NIOCore.ChannelOutboundInvoker {
}
public enum CloseMode : Swift.Sendable {
  case output
  case input
  case all
  public static func == (a: NIOCore.CloseMode, b: NIOCore.CloseMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ChannelOption : NIOCore._NIOPreconcurrencySendable, Swift.Equatable {
  associatedtype Value : Swift.Sendable
}
public typealias SocketOptionName = Swift.Int32
public typealias SocketOptionLevel = Swift.CInt
public typealias SocketOptionValue = Swift.CInt
@available(*, deprecated, renamed: "ChannelOptions.Types.SocketOption")
public typealias SocketOption = NIOCore.ChannelOptions.Types.SocketOption
@available(*, deprecated, renamed: "ChannelOptions.Types.AllocatorOption")
public typealias AllocatorOption = NIOCore.ChannelOptions.Types.AllocatorOption
@available(*, deprecated, renamed: "ChannelOptions.Types.RecvAllocatorOption")
public typealias RecvAllocatorOption = NIOCore.ChannelOptions.Types.RecvAllocatorOption
@available(*, deprecated, renamed: "ChannelOptions.Types.AutoReadOption")
public typealias AutoReadOption = NIOCore.ChannelOptions.Types.AutoReadOption
@available(*, deprecated, renamed: "ChannelOptions.Types.WriteSpinOption")
public typealias WriteSpinOption = NIOCore.ChannelOptions.Types.WriteSpinOption
@available(*, deprecated, renamed: "ChannelOptions.Types.MaxMessagesPerReadOption")
public typealias MaxMessagesPerReadOption = NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption
@available(*, deprecated, renamed: "ChannelOptions.Types.BacklogOption")
public typealias BacklogOption = NIOCore.ChannelOptions.Types.BacklogOption
@available(*, deprecated, renamed: "ChannelOptions.Types.DatagramVectorReadMessageCountOption")
public typealias DatagramVectorReadMessageCountOption = NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption
@available(*, deprecated, renamed: "ChannelOptions.Types.WriteBufferWaterMark")
public typealias WriteBufferWaterMark = NIOCore.ChannelOptions.Types.WriteBufferWaterMark
@available(*, deprecated, renamed: "ChannelOptions.Types.WriteBufferWaterMarkOption")
public typealias WriteBufferWaterMarkOption = NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption
@available(*, deprecated, renamed: "ChannelOptions.Types.ConnectTimeoutOption")
public typealias ConnectTimeoutOption = NIOCore.ChannelOptions.Types.ConnectTimeoutOption
@available(*, deprecated, renamed: "ChannelOptions.Types.AllowRemoteHalfClosureOption")
public typealias AllowRemoteHalfClosureOption = NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption
extension NIOCore.ChannelOptions {
  public enum Types : Swift.Sendable {
    public struct SocketOption : NIOCore.ChannelOption, Swift.Equatable, Swift.Sendable {
      public typealias Value = (NIOCore.SocketOptionValue)
      public var optionLevel: NIOCore.NIOBSDSocket.OptionLevel
      public var optionName: NIOCore.NIOBSDSocket.Option
      public var level: NIOCore.SocketOptionLevel {
        get
        set
      }
      public var name: NIOCore.SocketOptionName {
        get
        set
      }
      public init(level: NIOCore.SocketOptionLevel, name: NIOCore.SocketOptionName)
      public init(level: NIOCore.NIOBSDSocket.OptionLevel, name: NIOCore.NIOBSDSocket.Option)
      public static func == (a: NIOCore.ChannelOptions.Types.SocketOption, b: NIOCore.ChannelOptions.Types.SocketOption) -> Swift.Bool
    }
    public struct AllocatorOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = NIOCore.ByteBufferAllocator
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.AllocatorOption, b: NIOCore.ChannelOptions.Types.AllocatorOption) -> Swift.Bool
    }
    public struct RecvAllocatorOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = NIOCore.RecvByteBufferAllocator
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.RecvAllocatorOption, b: NIOCore.ChannelOptions.Types.RecvAllocatorOption) -> Swift.Bool
    }
    public struct AutoReadOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Bool
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.AutoReadOption, b: NIOCore.ChannelOptions.Types.AutoReadOption) -> Swift.Bool
    }
    public struct WriteSpinOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.UInt
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.WriteSpinOption, b: NIOCore.ChannelOptions.Types.WriteSpinOption) -> Swift.Bool
    }
    public struct MaxMessagesPerReadOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.UInt
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption, b: NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption) -> Swift.Bool
    }
    public struct BacklogOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Int32
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.BacklogOption, b: NIOCore.ChannelOptions.Types.BacklogOption) -> Swift.Bool
    }
    public struct DatagramVectorReadMessageCountOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Int
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption, b: NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption) -> Swift.Bool
    }
    public struct DatagramSegmentSize : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.CInt
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.DatagramSegmentSize, b: NIOCore.ChannelOptions.Types.DatagramSegmentSize) -> Swift.Bool
    }
    public struct DatagramReceiveOffload : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Bool
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.DatagramReceiveOffload, b: NIOCore.ChannelOptions.Types.DatagramReceiveOffload) -> Swift.Bool
    }
    public struct ExplicitCongestionNotificationsOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Bool
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption, b: NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption) -> Swift.Bool
    }
    public struct WriteBufferWaterMark : Swift.Sendable {
      public let low: Swift.Int
      public let high: Swift.Int
      public init(low: Swift.Int, high: Swift.Int)
    }
    public struct WriteBufferWaterMarkOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = NIOCore.ChannelOptions.Types.WriteBufferWaterMark
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption, b: NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption) -> Swift.Bool
    }
    public struct ConnectTimeoutOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = NIOCore.TimeAmount?
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.ConnectTimeoutOption, b: NIOCore.ChannelOptions.Types.ConnectTimeoutOption) -> Swift.Bool
    }
    public struct AllowRemoteHalfClosureOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Bool
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption, b: NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption) -> Swift.Bool
    }
    public struct ReceivePacketInfo : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Bool
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.ReceivePacketInfo, b: NIOCore.ChannelOptions.Types.ReceivePacketInfo) -> Swift.Bool
    }
    public struct BufferedWritableBytesOption : NIOCore.ChannelOption, Swift.Sendable {
      public typealias Value = Swift.Int
      public init()
      public static func == (a: NIOCore.ChannelOptions.Types.BufferedWritableBytesOption, b: NIOCore.ChannelOptions.Types.BufferedWritableBytesOption) -> Swift.Bool
    }
  }
}
public struct ChannelOptions : Swift.Sendable {
  public static let socket: @Sendable (_ level: NIOCore.SocketOptionLevel, _ name: NIOCore.SocketOptionName) -> NIOCore.ChannelOptions.Types.SocketOption
  public static let socketOption: @Sendable (_ name: NIOCore.NIOBSDSocket.Option) -> NIOCore.ChannelOptions.Types.SocketOption
  public static let ipOption: @Sendable (_ name: NIOCore.NIOBSDSocket.Option) -> NIOCore.ChannelOptions.Types.SocketOption
  public static let tcpOption: @Sendable (_ name: NIOCore.NIOBSDSocket.Option) -> NIOCore.ChannelOptions.Types.SocketOption
  public static let allocator: NIOCore.ChannelOptions.Types.AllocatorOption
  public static let recvAllocator: NIOCore.ChannelOptions.Types.RecvAllocatorOption
  public static let autoRead: NIOCore.ChannelOptions.Types.AutoReadOption
  public static let maxMessagesPerRead: NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption
  public static let backlog: NIOCore.ChannelOptions.Types.BacklogOption
  public static let writeSpin: NIOCore.ChannelOptions.Types.WriteSpinOption
  public static let writeBufferWaterMark: NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption
  public static let connectTimeout: NIOCore.ChannelOptions.Types.ConnectTimeoutOption
  public static let allowRemoteHalfClosure: NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption
  public static let datagramVectorReadMessageCount: NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption
  public static let datagramSegmentSize: NIOCore.ChannelOptions.Types.DatagramSegmentSize
  public static let datagramReceiveOffload: NIOCore.ChannelOptions.Types.DatagramReceiveOffload
  public static let explicitCongestionNotification: NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption
  public static let receivePacketInfo: NIOCore.ChannelOptions.Types.ReceivePacketInfo
  public static let bufferedWritableBytes: NIOCore.ChannelOptions.Types.BufferedWritableBytesOption
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.SocketOption {
  public static func socket(_ level: NIOCore.SocketOptionLevel, _ name: NIOCore.SocketOptionName) -> Self
  public static func socketOption(_ name: NIOCore.NIOBSDSocket.Option) -> Self
  public static func ipOption(_ name: NIOCore.NIOBSDSocket.Option) -> Self
  public static func tcpOption(_ name: NIOCore.NIOBSDSocket.Option) -> Self
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.AllocatorOption {
  public static var allocator: NIOCore.ChannelOptions.Types.AllocatorOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.RecvAllocatorOption {
  public static var recvAllocator: NIOCore.ChannelOptions.Types.RecvAllocatorOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.AutoReadOption {
  public static var autoRead: NIOCore.ChannelOptions.Types.AutoReadOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption {
  public static var maxMessagesPerRead: NIOCore.ChannelOptions.Types.MaxMessagesPerReadOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.BacklogOption {
  public static var backlog: NIOCore.ChannelOptions.Types.BacklogOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.WriteSpinOption {
  public static var writeSpin: NIOCore.ChannelOptions.Types.WriteSpinOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption {
  public static var writeBufferWaterMark: NIOCore.ChannelOptions.Types.WriteBufferWaterMarkOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.ConnectTimeoutOption {
  public static var connectTimeout: NIOCore.ChannelOptions.Types.ConnectTimeoutOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption {
  public static var allowRemoteHalfClosure: NIOCore.ChannelOptions.Types.AllowRemoteHalfClosureOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption {
  public static var datagramVectorReadMessageCount: NIOCore.ChannelOptions.Types.DatagramVectorReadMessageCountOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.DatagramSegmentSize {
  public static var datagramSegmentSize: NIOCore.ChannelOptions.Types.DatagramSegmentSize {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.DatagramReceiveOffload {
  public static var datagramReceiveOffload: NIOCore.ChannelOptions.Types.DatagramReceiveOffload {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption {
  public static var explicitCongestionNotification: NIOCore.ChannelOptions.Types.ExplicitCongestionNotificationsOption {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.ReceivePacketInfo {
  public static var receivePacketInfo: NIOCore.ChannelOptions.Types.ReceivePacketInfo {
    get
  }
}
extension NIOCore.ChannelOption where Self == NIOCore.ChannelOptions.Types.BufferedWritableBytesOption {
  public static var bufferedWritableBytes: NIOCore.ChannelOptions.Types.BufferedWritableBytesOption {
    get
  }
}
extension NIOCore.ChannelOptions {
  public struct Storage : Swift.Sendable {
    public init()
    public mutating func append<Option>(key newKey: Option, value newValue: Option.Value) where Option : NIOCore.ChannelOption
    public func applyAllChannelOptions(to channel: any NIOCore.Channel) -> NIOCore.EventLoopFuture<Swift.Void>
    public mutating func remove<Option>(key: Option) where Option : NIOCore.ChannelOption
  }
}
final public class ChannelPipeline : NIOCore.ChannelInvoker {
  final public let eventLoop: any NIOCore.EventLoop
  @preconcurrency final public func addHandler(_ handler: any NIOCore.ChannelHandler & Swift.Sendable, name: Swift.String? = nil, position: NIOCore.ChannelPipeline.Position = .last) -> NIOCore.EventLoopFuture<Swift.Void>
  @preconcurrency final public func removeHandler(_ handler: any NIOCore.RemovableChannelHandler & Swift.Sendable) -> NIOCore.EventLoopFuture<Swift.Void>
  final public func removeHandler(name: Swift.String) -> NIOCore.EventLoopFuture<Swift.Void>
  @available(*, deprecated, message: "Use .syncOperations.removeHandler(context:) instead, this method is not Sendable-safe.")
  final public func removeHandler(context: NIOCore.ChannelHandlerContext) -> NIOCore.EventLoopFuture<Swift.Void>
  @preconcurrency final public func removeHandler(_ handler: any NIOCore.RemovableChannelHandler & Swift.Sendable, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func removeHandler(name: Swift.String, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @available(*, deprecated, message: "Use .syncOperations.removeHandler(context:) instead, this method is not Sendable-safe.")
  final public func removeHandler(context: NIOCore.ChannelHandlerContext, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @available(*, deprecated, message: "This method is not strict concurrency safe. Prefer .syncOperations.context(handler:)")
  @preconcurrency final public func context(handler: any NIOCore.ChannelHandler & Swift.Sendable) -> NIOCore.EventLoopFuture<NIOCore.ChannelHandlerContext>
  final public func context(name: Swift.String) -> NIOCore.EventLoopFuture<NIOCore.ChannelHandlerContext>
  final public func context<Handler>(handlerType: Handler.Type) -> NIOCore.EventLoopFuture<NIOCore.ChannelHandlerContext> where Handler : NIOCore.ChannelHandler
  final public func containsHandler<Handler>(type: Handler.Type) -> NIOCore.EventLoopFuture<Swift.Void> where Handler : NIOCore.ChannelHandler
  final public func containsHandler(name: Swift.String) -> NIOCore.EventLoopFuture<Swift.Void>
  final public func fireChannelRegistered()
  final public func fireChannelUnregistered()
  final public func fireChannelInactive()
  final public func fireChannelActive()
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  final public func fireChannelRead(_ data: NIOCore.NIOAny)
  final public func fireChannelRead<T>(_ data: T) where T : Swift.Sendable
  final public func fireChannelReadComplete()
  final public func fireChannelWritabilityChanged()
  @preconcurrency final public func fireUserInboundEventTriggered(_ event: any Swift.Sendable)
  final public func fireErrorCaught(_ error: any Swift.Error)
  final public func close(mode: NIOCore.CloseMode = .all, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func flush()
  final public func read()
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  final public func write(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func write<T>(_ data: T, promise: NIOCore.EventLoopPromise<Swift.Void>?) where T : Swift.Sendable
  @available(*, deprecated, message: "NIOAny is not Sendable. Avoid wrapping the value in NIOAny to silence this warning.")
  final public func writeAndFlush(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func writeAndFlush<T>(_ data: T, promise: NIOCore.EventLoopPromise<Swift.Void>?) where T : Swift.Sendable
  final public func bind(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func connect(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func register(promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @preconcurrency final public func triggerUserOutboundEvent(_ event: any Swift.Sendable, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public init(channel: any NIOCore.Channel)
  @objc deinit
}
extension NIOCore.ChannelPipeline : @unchecked Swift.Sendable {
}
extension NIOCore.ChannelPipeline {
  @preconcurrency final public func addHandlers(_ handlers: [any NIOCore.ChannelHandler & Swift.Sendable], position: NIOCore.ChannelPipeline.Position = .last) -> NIOCore.EventLoopFuture<Swift.Void>
  @preconcurrency final public func addHandlers(_ handlers: (any NIOCore.ChannelHandler & Swift.Sendable)..., position: NIOCore.ChannelPipeline.Position = .last) -> NIOCore.EventLoopFuture<Swift.Void>
}
extension NIOCore.ChannelPipeline {
  public struct SynchronousOperations {
    public var eventLoop: any NIOCore.EventLoop {
      get
    }
    public func addHandler(_ handler: any NIOCore.ChannelHandler, name: Swift.String? = nil, position: NIOCore.ChannelPipeline.SynchronousOperations.Position = .last) throws
    @available(*, deprecated, message: "Use ChannelPipeline.SynchronousOperations.Position instead")
    @_disfavoredOverload public func addHandler(_ handler: any NIOCore.ChannelHandler, name: Swift.String? = nil, position: NIOCore.ChannelPipeline.Position = .last) throws
    public func addHandlers(_ handlers: [any NIOCore.ChannelHandler], position: NIOCore.ChannelPipeline.SynchronousOperations.Position = .last) throws
    @available(*, deprecated, message: "Use ChannelPipeline.SynchronousOperations.Position instead")
    @_disfavoredOverload public func addHandlers(_ handlers: [any NIOCore.ChannelHandler], position: NIOCore.ChannelPipeline.Position = .last) throws
    public func addHandlers(_ handlers: any NIOCore.ChannelHandler..., position: NIOCore.ChannelPipeline.SynchronousOperations.Position = .last) throws
    @available(*, deprecated, message: "Use ChannelPipeline.SynchronousOperations.Position instead")
    @_disfavoredOverload public func addHandlers(_ handlers: any NIOCore.ChannelHandler..., position: NIOCore.ChannelPipeline.Position = .last) throws
    public func removeHandler(_ handler: any NIOCore.RemovableChannelHandler) -> NIOCore.EventLoopFuture<Swift.Void>
    public func removeHandler(_ handler: any NIOCore.RemovableChannelHandler, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func removeHandler(name: Swift.String) -> NIOCore.EventLoopFuture<Swift.Void>
    public func removeHandler(name: Swift.String, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func removeHandler(context: NIOCore.ChannelHandlerContext) -> NIOCore.EventLoopFuture<Swift.Void>
    public func removeHandler(context: NIOCore.ChannelHandlerContext, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func context(handler: any NIOCore.ChannelHandler) throws -> NIOCore.ChannelHandlerContext
    public func context(name: Swift.String) throws -> NIOCore.ChannelHandlerContext
    public func context<Handler>(handlerType: Handler.Type) throws -> NIOCore.ChannelHandlerContext where Handler : NIOCore.ChannelHandler
    public func handler<Handler>(type _: Handler.Type) throws -> Handler where Handler : NIOCore.ChannelHandler
    public func fireChannelRegistered()
    public func fireChannelUnregistered()
    public func fireChannelInactive()
    public func fireChannelActive()
    public func fireChannelRead(_ data: NIOCore.NIOAny)
    public func fireChannelReadComplete()
    public func fireChannelWritabilityChanged()
    public func fireUserInboundEventTriggered(_ event: Any)
    public func fireErrorCaught(_ error: any Swift.Error)
    public func close(mode: NIOCore.CloseMode = .all, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func flush()
    public func read()
    public func write(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func write(_ data: NIOCore.NIOAny) -> NIOCore.EventLoopFuture<Swift.Void>
    public func writeAndFlush(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func writeAndFlush(_ data: NIOCore.NIOAny) -> NIOCore.EventLoopFuture<Swift.Void>
    public func bind(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func connect(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func register(promise: NIOCore.EventLoopPromise<Swift.Void>?)
    public func triggerUserOutboundEvent(_ event: Any, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  }
  final public var syncOperations: NIOCore.ChannelPipeline.SynchronousOperations {
    get
  }
}
@available(*, unavailable)
extension NIOCore.ChannelPipeline.SynchronousOperations : Swift.Sendable {
}
extension NIOCore.ChannelPipeline {
  @preconcurrency public enum Position : Swift.Sendable {
    case first
    case last
    case before(any NIOCore.ChannelHandler & Swift.Sendable)
    case after(any NIOCore.ChannelHandler & Swift.Sendable)
  }
}
extension NIOCore.ChannelPipeline.SynchronousOperations {
  public enum Position {
    case first
    case last
    case before(any NIOCore.ChannelHandler)
    case after(any NIOCore.ChannelHandler)
    public init(_ position: NIOCore.ChannelPipeline.Position)
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, unavailable)
extension NIOCore.ChannelPipeline.SynchronousOperations.Position : Swift.Sendable {
}
public enum ChannelPipelineError : Swift.Error {
  case alreadyRemoved
  case notFound
  public static func == (a: NIOCore.ChannelPipelineError, b: NIOCore.ChannelPipelineError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ChannelHandlerContext : NIOCore.ChannelInvoker {
  final public let pipeline: NIOCore.ChannelPipeline
  final public var channel: any NIOCore.Channel {
    get
  }
  final public var handler: any NIOCore.ChannelHandler {
    get
  }
  final public var remoteAddress: NIOCore.SocketAddress? {
    get
  }
  final public var localAddress: NIOCore.SocketAddress? {
    get
  }
  final public var eventLoop: any NIOCore.EventLoop {
    get
  }
  final public let name: Swift.String
  final public func fireChannelRegistered()
  final public func fireChannelUnregistered()
  final public func fireChannelActive()
  final public func fireChannelInactive()
  final public func fireChannelRead(_ data: NIOCore.NIOAny)
  final public func fireChannelReadComplete()
  final public func fireChannelWritabilityChanged()
  final public func fireErrorCaught(_ error: any Swift.Error)
  @available(*, deprecated)
  @_disfavoredOverload final public func fireUserInboundEventTriggered(_ event: any Swift.Sendable)
  final public func fireUserInboundEventTriggered(_ event: Any)
  final public func register(promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func bind(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func connect(to address: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func write(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func flush()
  final public func writeAndFlush(_ data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func read()
  final public func close(mode: NIOCore.CloseMode = .all, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @available(*, deprecated)
  @_disfavoredOverload final public func triggerUserOutboundEvent(_ event: any Swift.Sendable, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func triggerUserOutboundEvent(_ event: Any, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @objc deinit
}
extension NIOCore.ChannelHandlerContext {
  final public func write(_ data: NIOCore.NIOAny, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  final public func writeAndFlush(_ data: NIOCore.NIOAny, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Swift.Void>
  final public var loopBound: NIOCore.NIOLoopBound<NIOCore.ChannelHandlerContext> {
    get
  }
}
@available(*, unavailable)
extension NIOCore.ChannelHandlerContext : Swift.Sendable {
}
extension NIOCore.ChannelHandlerContext {
  public struct RemovalToken : Swift.Sendable {
  }
  final public func leavePipeline(removalToken: NIOCore.ChannelHandlerContext.RemovalToken)
}
extension NIOCore.ChannelPipeline : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
  final public func handler<Handler>(type _: Handler.Type) -> NIOCore.EventLoopFuture<Handler> where Handler : NIOCore.ChannelHandler
}
extension NIOCore.ChannelPipeline {
  final public func outboundBufferedBytes() -> NIOCore.EventLoopFuture<Swift.Int>
  final public func inboundBufferedBytes() -> NIOCore.EventLoopFuture<Swift.Int>
}
extension NIOCore.ChannelPipeline.SynchronousOperations {
  public func outboundBufferedBytes() -> Swift.Int
  public func outboundBufferedBytes(in context: NIOCore.ChannelHandlerContext) -> Swift.Int?
  public func inboundBufferedBytes() -> Swift.Int
  public func inboundBufferedBytes(in context: NIOCore.ChannelHandlerContext) -> Swift.Int?
}
public struct CircularBuffer<Element> : Swift.CustomStringConvertible {
  public struct Index : Swift.Comparable, Swift.Sendable {
    public static func == (lhs: NIOCore.CircularBuffer<Element>.Index, rhs: NIOCore.CircularBuffer<Element>.Index) -> Swift.Bool
    public static func < (lhs: NIOCore.CircularBuffer<Element>.Index, rhs: NIOCore.CircularBuffer<Element>.Index) -> Swift.Bool
  }
}
extension NIOCore.CircularBuffer : Swift.Collection, Swift.MutableCollection {
  public typealias Element = Element
  public typealias Indices = Swift.DefaultIndices<NIOCore.CircularBuffer<Element>>
  public typealias RangeType<Bound> = Swift.Range<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
  public typealias SubSequence = NIOCore.CircularBuffer<Element>
  public func index(after: NIOCore.CircularBuffer<Element>.Index) -> NIOCore.CircularBuffer<Element>.Index
  public func index(before: NIOCore.CircularBuffer<Element>.Index) -> NIOCore.CircularBuffer<Element>.Index
  public subscript(position: NIOCore.CircularBuffer<Element>.Index) -> Element {
    get
    set
  }
  public var startIndex: NIOCore.CircularBuffer<Element>.Index {
    get
  }
  public var endIndex: NIOCore.CircularBuffer<Element>.Index {
    get
  }
  public func distance(from start: NIOCore.CircularBuffer<Element>.Index, to end: NIOCore.CircularBuffer<Element>.Index) -> Swift.Int
  public func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (Swift.IndexingIterator<NIOCore.CircularBuffer<Element>>, Swift.UnsafeMutableBufferPointer<Element>.Index)
  public func _failEarlyRangeCheck(_ index: NIOCore.CircularBuffer<Element>.Index, bounds: Swift.Range<NIOCore.CircularBuffer<Element>.Index>)
  public func _failEarlyRangeCheck(_ index: NIOCore.CircularBuffer<Element>.Index, bounds: Swift.ClosedRange<NIOCore.CircularBuffer<Element>.Index>)
  public func _failEarlyRangeCheck(_ range: Swift.Range<NIOCore.CircularBuffer<Element>.Index>, bounds: Swift.Range<NIOCore.CircularBuffer<Element>.Index>)
  public typealias Iterator = Swift.IndexingIterator<NIOCore.CircularBuffer<Element>>
}
extension NIOCore.CircularBuffer : Swift.RandomAccessCollection {
  public func index(_ i: NIOCore.CircularBuffer<Element>.Index, offsetBy distance: Swift.Int) -> NIOCore.CircularBuffer<Element>.Index
  public subscript(bounds: Swift.Range<NIOCore.CircularBuffer<Element>.Index>) -> NIOCore.CircularBuffer<Element>.SubSequence {
    get
    set
  }
}
extension NIOCore.CircularBuffer {
  public init(initialCapacity: Swift.Int)
  public init()
  public mutating func append(_ value: Element)
  public mutating func prepend(_ value: Element)
  public subscript(offset offset: Swift.Int) -> Element {
    get
    set
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var capacity: Swift.Int {
    get
  }
  public mutating func removeAll(keepingCapacity: Swift.Bool = false)
  public mutating func modify<Result>(_ index: NIOCore.CircularBuffer<Element>.Index, _ modifyFunc: (inout Element) throws -> Result) rethrows -> Result
  public var description: Swift.String {
    get
  }
}
extension NIOCore.CircularBuffer : Swift.RangeReplaceableCollection {
  public mutating func popFirst() -> Element?
  public mutating func popLast() -> Element?
  public mutating func removeLast(_ k: Swift.Int)
  public mutating func removeFirst(_ k: Swift.Int)
  @discardableResult
  public mutating func removeFirst() -> Element
  @discardableResult
  public mutating func removeLast() -> Element
  public mutating func replaceSubrange<C>(_ subrange: Swift.Range<NIOCore.CircularBuffer<Element>.Index>, with newElements: C) where Element == C.Element, C : Swift.Collection
  public mutating func removeSubrange(_ bounds: Swift.Range<NIOCore.CircularBuffer<Element>.Index>)
  @discardableResult
  public mutating func remove(at position: NIOCore.CircularBuffer<Element>.Index) -> Element
  public var first: Element? {
    get
  }
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
}
extension NIOCore.CircularBuffer : Swift.Equatable where Element : Swift.Equatable {
  public static func == (lhs: NIOCore.CircularBuffer<Element>, rhs: NIOCore.CircularBuffer<Element>) -> Swift.Bool
}
extension NIOCore.CircularBuffer : Swift.Hashable where Element : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.CircularBuffer : Swift.Sendable where Element : Swift.Sendable {
}
extension NIOCore.CircularBuffer : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Element...)
  public typealias ArrayLiteralElement = Element
}
public enum DecodingState : Swift.Sendable {
  case `continue`
  case needMoreData
  public static func == (a: NIOCore.DecodingState, b: NIOCore.DecodingState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ByteToMessageDecoderError : Swift.Error {
  case dataReceivedInErrorState(any Swift.Error, NIOCore.ByteBuffer)
  case leftoverDataWhenDone(NIOCore.ByteBuffer)
}
extension NIOCore.ByteToMessageDecoderError {
  public struct PayloadTooLargeError : Swift.Error {
    public init()
  }
}
public protocol ByteToMessageDecoder {
  associatedtype InboundOut
  mutating func decode(context: NIOCore.ChannelHandlerContext, buffer: inout NIOCore.ByteBuffer) throws -> NIOCore.DecodingState
  mutating func decodeLast(context: NIOCore.ChannelHandlerContext, buffer: inout NIOCore.ByteBuffer, seenEOF: Swift.Bool) throws -> NIOCore.DecodingState
  mutating func decoderRemoved(context: NIOCore.ChannelHandlerContext)
  mutating func decoderAdded(context: NIOCore.ChannelHandlerContext)
  mutating func shouldReclaimBytes(buffer: NIOCore.ByteBuffer) -> Swift.Bool
}
public protocol WriteObservingByteToMessageDecoder : NIOCore.ByteToMessageDecoder {
  associatedtype OutboundIn
  mutating func write(data: Self.OutboundIn)
}
extension NIOCore.ByteToMessageDecoder {
  public mutating func decoderRemoved(context: NIOCore.ChannelHandlerContext)
  public mutating func decoderAdded(context: NIOCore.ChannelHandlerContext)
  public func shouldReclaimBytes(buffer: NIOCore.ByteBuffer) -> Swift.Bool
  public func wrapInboundOut(_ value: Self.InboundOut) -> NIOCore.NIOAny
  public static func wrapInboundOut(_ value: Self.InboundOut) -> NIOCore.NIOAny
  public mutating func decodeLast(context: NIOCore.ChannelHandlerContext, buffer: inout NIOCore.ByteBuffer, seenEOF: Swift.Bool) throws -> NIOCore.DecodingState
}
final public class ByteToMessageHandler<Decoder> where Decoder : NIOCore.ByteToMessageDecoder {
  public typealias InboundIn = NIOCore.ByteBuffer
  public typealias InboundOut = Decoder.InboundOut
  convenience public init(_ decoder: Decoder)
  public init(_ decoder: Decoder, maximumBufferSize: Swift.Int? = nil)
  @objc deinit
}
@available(*, unavailable)
extension NIOCore.ByteToMessageHandler : Swift.Sendable {
}
extension NIOCore.ByteToMessageHandler : NIOCore.ChannelInboundHandler {
  final public func handlerAdded(context: NIOCore.ChannelHandlerContext)
  final public func handlerRemoved(context: NIOCore.ChannelHandlerContext)
  final public func channelRead(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny)
  final public func channelInactive(context: NIOCore.ChannelHandlerContext)
  final public func userInboundEventTriggered(context: NIOCore.ChannelHandlerContext, event: Any)
  public typealias OutboundOut = Swift.Never
}
extension NIOCore.ByteToMessageHandler : NIOCore.ChannelOutboundHandler, NIOCore._ChannelOutboundHandler where Decoder : NIOCore.WriteObservingByteToMessageDecoder {
  public typealias OutboundIn = Decoder.OutboundIn
  final public func write(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
}
public protocol MessageToByteEncoder {
  associatedtype OutboundIn
  func encode(data: Self.OutboundIn, out: inout NIOCore.ByteBuffer) throws
}
extension NIOCore.ByteToMessageHandler : NIOCore.RemovableChannelHandler {
  final public func removeHandler(context: NIOCore.ChannelHandlerContext, removalToken: NIOCore.ChannelHandlerContext.RemovalToken)
}
final public class MessageToByteHandler<Encoder> : NIOCore.ChannelOutboundHandler where Encoder : NIOCore.MessageToByteEncoder {
  public typealias OutboundOut = NIOCore.ByteBuffer
  public typealias OutboundIn = Encoder.OutboundIn
  public init(_ encoder: Encoder, desiredBufferCapacity: Swift.Int)
  public init(_ encoder: Encoder)
  @objc deinit
}
@available(*, unavailable)
extension NIOCore.MessageToByteHandler : Swift.Sendable {
}
extension NIOCore.MessageToByteHandler {
  final public func handlerAdded(context: NIOCore.ChannelHandlerContext)
  final public func handlerRemoved(context: NIOCore.ChannelHandlerContext)
  final public func write(context: NIOCore.ChannelHandlerContext, data: NIOCore.NIOAny, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  final public func flush(context: NIOCore.ChannelHandlerContext)
}
extension NIOCore.NIOClientTCPBootstrapProtocol {
  public func _applyChannelConvenienceOptions(_ options: inout NIOCore.ChannelOptions.TCPConvenienceOptions) -> Self
}
extension NIOCore.NIOClientTCPBootstrap {
  public func channelConvenienceOptions(_ options: NIOCore.ChannelOptions.TCPConvenienceOptions) -> NIOCore.NIOClientTCPBootstrap
}
extension NIOCore.ChannelOptions.Types {
  public enum ConvenienceOptionValue<ValueType> {
    case notSet
    case set(ValueType)
  }
}
extension NIOCore.ChannelOptions.Types.ConvenienceOptionValue : Swift.Sendable where ValueType : Swift.Sendable {
}
extension NIOCore.ChannelOptions.Types.ConvenienceOptionValue where ValueType == () {
  public var isSet: Swift.Bool {
    get
  }
}
extension NIOCore.ChannelOptions {
  public struct TCPConvenienceOption : Swift.Hashable, Swift.Sendable {
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NIOCore.ChannelOptions.TCPConvenienceOption, b: NIOCore.ChannelOptions.TCPConvenienceOption) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension NIOCore.ChannelOptions.TCPConvenienceOption {
  public static let allowLocalEndpointReuse: NIOCore.ChannelOptions.TCPConvenienceOption
  public static let disableAutoRead: NIOCore.ChannelOptions.TCPConvenienceOption
  public static let allowRemoteHalfClosure: NIOCore.ChannelOptions.TCPConvenienceOption
}
extension NIOCore.ChannelOptions {
  public struct TCPConvenienceOptions : Swift.ExpressibleByArrayLiteral, Swift.Hashable, Swift.Sendable {
    public init(arrayLiteral elements: NIOCore.ChannelOptions.TCPConvenienceOption...)
    public mutating func consumeAllowLocalEndpointReuse() -> NIOCore.ChannelOptions.Types.ConvenienceOptionValue<Swift.Void>
    public mutating func consumeDisableAutoRead() -> NIOCore.ChannelOptions.Types.ConvenienceOptionValue<Swift.Void>
    public mutating func consumeAllowRemoteHalfClosure() -> NIOCore.ChannelOptions.Types.ConvenienceOptionValue<Swift.Void>
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NIOCore.ChannelOptions.TCPConvenienceOptions, b: NIOCore.ChannelOptions.TCPConvenienceOptions) -> Swift.Bool
    public typealias ArrayLiteralElement = NIOCore.ChannelOptions.TCPConvenienceOption
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Dispatch.DispatchQueue {
  @preconcurrency public func asyncWithFuture<NewValue>(eventLoop: any NIOCore.EventLoop, _ callbackMayBlock: @escaping @Sendable () throws -> NewValue) -> NIOCore.EventLoopFuture<NewValue> where NewValue : Swift.Sendable
}
extension NIOCore.EventLoop {
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  public func makeFailedFuture<T>(_ error: any Swift.Error, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<T>
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  @preconcurrency public func makeSucceededFuture<Success>(_ value: Success, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Success> where Success : Swift.Sendable
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
public protocol NIOSerialEventLoopExecutor : NIOCore.EventLoop, _Concurrency.SerialExecutor {
}
@available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
extension NIOCore.NIOSerialEventLoopExecutor {
  public func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  public func asUnownedSerialExecutor() -> _Concurrency.UnownedSerialExecutor
  public var executor: any _Concurrency.SerialExecutor {
    get
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func isSameExclusiveExecutionContext(other: Self) -> Swift.Bool
  @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, *)
  public func checkIsolated()
}
public struct Scheduled<T> {
  @preconcurrency public init(promise: NIOCore.EventLoopPromise<T>, cancellationTask: @escaping @Sendable () -> Swift.Void)
  public func cancel()
  public var futureResult: NIOCore.EventLoopFuture<T> {
    get
  }
}
extension NIOCore.Scheduled : Swift.Sendable {
}
@_hasMissingDesignatedInitializers final public class RepeatedTask {
  final public func cancel(promise: NIOCore.EventLoopPromise<Swift.Void>? = nil)
  @objc deinit
}
extension NIOCore.RepeatedTask : @unchecked Swift.Sendable {
}
public struct EventLoopIterator : Swift.Sequence, Swift.IteratorProtocol {
  public typealias Element = NIOCore.EventLoop
  public init(_ eventLoops: [any NIOCore.EventLoop])
  public mutating func next() -> (any NIOCore.EventLoop)?
  public typealias Iterator = NIOCore.EventLoopIterator
}
extension NIOCore.EventLoopIterator : Swift.Sendable {
}
public protocol EventLoop : NIOCore.EventLoopGroup {
  var inEventLoop: Swift.Bool { get }
  @preconcurrency func execute(_ task: @escaping @Sendable () -> Swift.Void)
  @preconcurrency func submit<T>(_ task: @escaping @Sendable () throws -> T) -> NIOCore.EventLoopFuture<T>
  var now: NIOCore.NIODeadline { get }
  @discardableResult
  @preconcurrency func scheduleTask<T>(deadline: NIOCore.NIODeadline, _ task: @escaping @Sendable () throws -> T) -> NIOCore.Scheduled<T>
  @discardableResult
  @preconcurrency func scheduleTask<T>(in: NIOCore.TimeAmount, _ task: @escaping @Sendable () throws -> T) -> NIOCore.Scheduled<T>
  func preconditionInEventLoop(file: Swift.StaticString, line: Swift.UInt)
  func preconditionNotInEventLoop(file: Swift.StaticString, line: Swift.UInt)
  func makeSucceededVoidFuture() -> NIOCore.EventLoopFuture<Swift.Void>
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  var executor: any _Concurrency.SerialExecutor { get }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  func enqueue(_ job: consuming _Concurrency.ExecutorJob)
  func _preconditionSafeToWait(file: Swift.StaticString, line: Swift.UInt)
  func _promiseCreated(futureIdentifier: NIOCore._NIOEventLoopFutureIdentifier, file: Swift.StaticString, line: Swift.UInt)
  func _promiseCompleted(futureIdentifier: NIOCore._NIOEventLoopFutureIdentifier) -> (file: Swift.StaticString, line: Swift.UInt)?
  @discardableResult
  @preconcurrency func scheduleCallback(at deadline: NIOCore.NIODeadline, handler: some (NIOScheduledCallbackHandler & Sendable)) throws -> NIOCore.NIOScheduledCallback
  @discardableResult
  @preconcurrency func scheduleCallback(in amount: NIOCore.TimeAmount, handler: some (NIOScheduledCallbackHandler & Sendable)) throws -> NIOCore.NIOScheduledCallback
  func cancelScheduledCallback(_ scheduledCallback: NIOCore.NIOScheduledCallback)
  func _executeIsolatedUnsafeUnchecked(_ task: @escaping () -> Swift.Void)
  func _submitIsolatedUnsafeUnchecked<T>(_ task: @escaping () throws -> T) -> NIOCore.EventLoopFuture<T>
  @discardableResult
  func _scheduleTaskIsolatedUnsafeUnchecked<T>(deadline: NIOCore.NIODeadline, _ task: @escaping () throws -> T) -> NIOCore.Scheduled<T>
  @discardableResult
  func _scheduleTaskIsolatedUnsafeUnchecked<T>(in: NIOCore.TimeAmount, _ task: @escaping () throws -> T) -> NIOCore.Scheduled<T>
}
extension NIOCore.EventLoop {
  public var now: NIOCore.NIODeadline {
    get
  }
}
extension NIOCore.EventLoop {
  public func makeSucceededVoidFuture() -> NIOCore.EventLoopFuture<Swift.Void>
  public func _preconditionSafeToWait(file: Swift.StaticString, line: Swift.UInt)
  public func _promiseCreated(futureIdentifier: NIOCore._NIOEventLoopFutureIdentifier, file: Swift.StaticString, line: Swift.UInt)
  public func _promiseCompleted(futureIdentifier: NIOCore._NIOEventLoopFutureIdentifier) -> (file: Swift.StaticString, line: Swift.UInt)?
  public func _executeIsolatedUnsafeUnchecked(_ task: @escaping () -> Swift.Void)
  public func _submitIsolatedUnsafeUnchecked<T>(_ task: @escaping () throws -> T) -> NIOCore.EventLoopFuture<T>
  @discardableResult
  public func _scheduleTaskIsolatedUnsafeUnchecked<T>(deadline: NIOCore.NIODeadline, _ task: @escaping () throws -> T) -> NIOCore.Scheduled<T>
  @discardableResult
  public func _scheduleTaskIsolatedUnsafeUnchecked<T>(in delay: NIOCore.TimeAmount, _ task: @escaping () throws -> T) -> NIOCore.Scheduled<T>
}
extension NIOCore.EventLoop {
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public var executor: any _Concurrency.SerialExecutor {
    get
  }
  @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
  public func enqueue(_ job: consuming _Concurrency.ExecutorJob)
}
extension NIOCore.EventLoopGroup {
  public var description: Swift.String {
    get
  }
}
public struct TimeAmount : Swift.Hashable, Swift.Sendable {
  @available(*, deprecated, message: "This typealias doesn't serve any purpose. Please use Int64 directly.")
  public typealias Value = Swift.Int64
  public let nanoseconds: Swift.Int64
  public static func nanoseconds(_ amount: Swift.Int64) -> NIOCore.TimeAmount
  public static func microseconds(_ amount: Swift.Int64) -> NIOCore.TimeAmount
  public static func milliseconds(_ amount: Swift.Int64) -> NIOCore.TimeAmount
  public static func seconds(_ amount: Swift.Int64) -> NIOCore.TimeAmount
  public static func minutes(_ amount: Swift.Int64) -> NIOCore.TimeAmount
  public static func hours(_ amount: Swift.Int64) -> NIOCore.TimeAmount
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NIOCore.TimeAmount, b: NIOCore.TimeAmount) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.TimeAmount : Swift.CustomStringConvertible {
  public init(_ userProvidedString: Swift.String) throws
  public var description: Swift.String {
    get
  }
}
extension NIOCore.TimeAmount : Swift.Comparable {
  public static func < (lhs: NIOCore.TimeAmount, rhs: NIOCore.TimeAmount) -> Swift.Bool
}
extension NIOCore.TimeAmount : Swift.AdditiveArithmetic {
  public static var zero: NIOCore.TimeAmount {
    get
  }
  public static func + (lhs: NIOCore.TimeAmount, rhs: NIOCore.TimeAmount) -> NIOCore.TimeAmount
  public static func += (lhs: inout NIOCore.TimeAmount, rhs: NIOCore.TimeAmount)
  public static func - (lhs: NIOCore.TimeAmount, rhs: NIOCore.TimeAmount) -> NIOCore.TimeAmount
  public static func -= (lhs: inout NIOCore.TimeAmount, rhs: NIOCore.TimeAmount)
  public static func * <T>(lhs: T, rhs: NIOCore.TimeAmount) -> NIOCore.TimeAmount where T : Swift.BinaryInteger
  public static func * <T>(lhs: NIOCore.TimeAmount, rhs: T) -> NIOCore.TimeAmount where T : Swift.BinaryInteger
}
public struct NIODeadline : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  @available(*, deprecated, message: "This typealias doesn't serve any purpose, please use UInt64 directly.")
  public typealias Value = Swift.UInt64
  public var uptimeNanoseconds: Swift.UInt64 {
    get
  }
  public static let distantPast: NIOCore.NIODeadline
  public static let distantFuture: NIOCore.NIODeadline
  public static func now() -> NIOCore.NIODeadline
  public static func uptimeNanoseconds(_ nanoseconds: Swift.UInt64) -> NIOCore.NIODeadline
  public static func == (lhs: NIOCore.NIODeadline, rhs: NIOCore.NIODeadline) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.NIODeadline : Swift.Comparable {
  public static func < (lhs: NIOCore.NIODeadline, rhs: NIOCore.NIODeadline) -> Swift.Bool
  public static func > (lhs: NIOCore.NIODeadline, rhs: NIOCore.NIODeadline) -> Swift.Bool
}
extension NIOCore.NIODeadline : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NIOCore.NIODeadline {
  public static func - (lhs: NIOCore.NIODeadline, rhs: NIOCore.NIODeadline) -> NIOCore.TimeAmount
  public static func + (lhs: NIOCore.NIODeadline, rhs: NIOCore.TimeAmount) -> NIOCore.NIODeadline
  public static func - (lhs: NIOCore.NIODeadline, rhs: NIOCore.TimeAmount) -> NIOCore.NIODeadline
}
extension NIOCore.EventLoop {
  @preconcurrency public func submit<T>(_ task: @escaping @Sendable () throws -> T) -> NIOCore.EventLoopFuture<T>
  @preconcurrency public func flatSubmit<T>(_ task: @escaping @Sendable () -> NIOCore.EventLoopFuture<T>) -> NIOCore.EventLoopFuture<T> where T : Swift.Sendable
  @discardableResult
  @preconcurrency public func flatScheduleTask<T>(deadline: NIOCore.NIODeadline, file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ task: @escaping @Sendable () throws -> NIOCore.EventLoopFuture<T>) -> NIOCore.Scheduled<T> where T : Swift.Sendable
  @discardableResult
  @preconcurrency public func flatScheduleTask<T>(in delay: NIOCore.TimeAmount, file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ task: @escaping @Sendable () throws -> NIOCore.EventLoopFuture<T>) -> NIOCore.Scheduled<T> where T : Swift.Sendable
  public func makePromise<T>(of type: T.Type = T.self, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopPromise<T>
  public func makeFailedFuture<T>(_ error: any Swift.Error) -> NIOCore.EventLoopFuture<T>
  @preconcurrency public func makeSucceededFuture<Success>(_ value: Success) -> NIOCore.EventLoopFuture<Success> where Success : Swift.Sendable
  @available(*, noasync)
  public func makeSucceededIsolatedFuture<Success>(_ value: Success) -> NIOCore.EventLoopFuture<Success>.Isolated
  @preconcurrency public func makeCompletedFuture<Success>(_ result: Swift.Result<Success, any Swift.Error>) -> NIOCore.EventLoopFuture<Success> where Success : Swift.Sendable
  @preconcurrency public func makeCompletedFuture<Success>(withResultOf body: () throws -> Success) -> NIOCore.EventLoopFuture<Success> where Success : Swift.Sendable
  public func next() -> any NIOCore.EventLoop
  public func any() -> any NIOCore.EventLoop
  public func close() throws
  @discardableResult
  @preconcurrency public func scheduleRepeatedTask(initialDelay: NIOCore.TimeAmount, delay: NIOCore.TimeAmount, notifying promise: NIOCore.EventLoopPromise<Swift.Void>? = nil, _ task: @escaping @Sendable (NIOCore.RepeatedTask) throws -> Swift.Void) -> NIOCore.RepeatedTask
  @discardableResult
  public func scheduleRepeatedTask(initialDelay: NIOCore.TimeAmount, delay: NIOCore.TimeAmount, maximumAllowableJitter: NIOCore.TimeAmount, notifying promise: NIOCore.EventLoopPromise<Swift.Void>? = nil, _ task: @escaping @Sendable (NIOCore.RepeatedTask) throws -> Swift.Void) -> NIOCore.RepeatedTask
  @discardableResult
  @preconcurrency public func scheduleRepeatedAsyncTask(initialDelay: NIOCore.TimeAmount, delay: NIOCore.TimeAmount, notifying promise: NIOCore.EventLoopPromise<Swift.Void>? = nil, _ task: @escaping @Sendable (NIOCore.RepeatedTask) -> NIOCore.EventLoopFuture<Swift.Void>) -> NIOCore.RepeatedTask
  @discardableResult
  public func scheduleRepeatedAsyncTask(initialDelay: NIOCore.TimeAmount, delay: NIOCore.TimeAmount, maximumAllowableJitter: NIOCore.TimeAmount, notifying promise: NIOCore.EventLoopPromise<Swift.Void>? = nil, _ task: @escaping @Sendable (NIOCore.RepeatedTask) -> NIOCore.EventLoopFuture<Swift.Void>) -> NIOCore.RepeatedTask
  public func makeIterator() -> NIOCore.EventLoopIterator
  public func assertInEventLoop(file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  public func assertNotInEventLoop(file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  public func preconditionInEventLoop(file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  public func preconditionNotInEventLoop(file: Swift.StaticString = #fileID, line: Swift.UInt = #line)
}
public protocol EventLoopGroup : AnyObject, NIOCore._NIOPreconcurrencySendable {
  func next() -> any NIOCore.EventLoop
  func any() -> any NIOCore.EventLoop
  @preconcurrency func shutdownGracefully(queue: Dispatch.DispatchQueue, _ callback: @escaping @Sendable ((any Swift.Error)?) -> Swift.Void)
  func makeIterator() -> NIOCore.EventLoopIterator
  func _preconditionSafeToSyncShutdown(file: Swift.StaticString, line: Swift.UInt)
}
extension NIOCore.EventLoopGroup {
  public func any() -> any NIOCore.EventLoop
}
extension NIOCore.EventLoopGroup {
  @preconcurrency public func shutdownGracefully(_ callback: @escaping @Sendable ((any Swift.Error)?) -> Swift.Void)
  @available(*, noasync, renamed: "shutdownGracefully()", message: "this can end up blocking the calling thread")
  public func syncShutdownGracefully() throws
  public func _preconditionSafeToSyncShutdown(file: Swift.StaticString, line: Swift.UInt)
}
public enum NIOEventLoopGroupProvider {
  case shared(any NIOCore.EventLoopGroup)
  @available(*, deprecated, message: "Please use `.shared(existingGroup)` or use the singleton via `.shared(MultiThreadedEventLoopGroup.singleton)` or similar")
  case createNew
}
extension NIOCore.NIOEventLoopGroupProvider : Swift.Sendable {
}
public enum EventLoopError : Swift.Error {
  case unsupportedOperation
  case cancelled
  case shutdown
  case shutdownFailed
  public static func == (a: NIOCore.EventLoopError, b: NIOCore.EventLoopError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.EventLoopError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct NIOIsolatedEventLoop {
  @available(*, noasync)
  public func execute(_ task: @escaping () -> Swift.Void)
  @available(*, noasync)
  public func submit<T>(_ task: @escaping () throws -> T) -> NIOCore.EventLoopFuture<T>
  @discardableResult
  @available(*, noasync)
  public func scheduleTask<T>(deadline: NIOCore.NIODeadline, _ task: @escaping () throws -> T) -> NIOCore.Scheduled<T>
  @discardableResult
  @available(*, noasync)
  public func scheduleTask<T>(in delay: NIOCore.TimeAmount, _ task: @escaping () throws -> T) -> NIOCore.Scheduled<T>
  @discardableResult
  @available(*, noasync)
  public func flatScheduleTask<T>(deadline: NIOCore.NIODeadline, file: Swift.StaticString = #file, line: Swift.UInt = #line, _ task: @escaping () throws -> NIOCore.EventLoopFuture<T>) -> NIOCore.Scheduled<T> where T : Swift.Sendable
  @available(*, noasync)
  public func makeSucceededFuture<Success>(_ value: Success) -> NIOCore.EventLoopFuture<Success>
  @available(*, noasync)
  public func makeFailedFuture<Success>(_ error: any Swift.Error) -> NIOCore.EventLoopFuture<Success>
  @available(*, noasync)
  public func makeCompletedFuture<Success>(_ result: Swift.Result<Success, any Swift.Error>) -> NIOCore.EventLoopFuture<Success>
  @available(*, noasync)
  public func makeCompletedFuture<Success>(withResultOf body: () throws -> Success) -> NIOCore.EventLoopFuture<Success>
  public func nonisolated() -> any NIOCore.EventLoop
}
extension NIOCore.EventLoop {
  @available(*, noasync)
  public func assumeIsolated() -> NIOCore.NIOIsolatedEventLoop
  public func assumeIsolatedUnsafeUnchecked() -> NIOCore.NIOIsolatedEventLoop
}
@available(*, unavailable)
extension NIOCore.NIOIsolatedEventLoop : Swift.Sendable {
}
extension NIOCore.EventLoopFuture {
  public struct Isolated {
    @available(*, noasync)
    public func flatMap<NewValue>(_ callback: @escaping (Value) -> NIOCore.EventLoopFuture<NewValue>) -> NIOCore.EventLoopFuture<NewValue>.Isolated where NewValue : Swift.Sendable
    @available(*, noasync)
    public func flatMapThrowing<NewValue>(_ callback: @escaping (Value) throws -> NewValue) -> NIOCore.EventLoopFuture<NewValue>.Isolated
    @available(*, noasync)
    public func flatMapErrorThrowing(_ callback: @escaping (any Swift.Error) throws -> Value) -> NIOCore.EventLoopFuture<Value>.Isolated
    @available(*, noasync)
    public func map<NewValue>(_ callback: @escaping (Value) -> (NewValue)) -> NIOCore.EventLoopFuture<NewValue>.Isolated
    @available(*, noasync)
    public func flatMapError(_ callback: @escaping (any Swift.Error) -> NIOCore.EventLoopFuture<Value>) -> NIOCore.EventLoopFuture<Value>.Isolated where Value : Swift.Sendable
    @available(*, noasync)
    public func flatMapError(_ callback: @escaping (any Swift.Error) -> NIOCore.EventLoopFuture<Value>.Isolated) -> NIOCore.EventLoopFuture<Value>.Isolated
    @available(*, noasync)
    public func flatMapResult<NewValue, SomeError>(_ body: @escaping (Value) -> Swift.Result<NewValue, SomeError>) -> NIOCore.EventLoopFuture<NewValue>.Isolated where SomeError : Swift.Error
    @available(*, noasync)
    public func recover(_ callback: @escaping (any Swift.Error) -> Value) -> NIOCore.EventLoopFuture<Value>.Isolated
    @available(*, noasync)
    public func whenSuccess(_ callback: @escaping (Value) -> Swift.Void)
    @available(*, noasync)
    public func whenFailure(_ callback: @escaping (any Swift.Error) -> Swift.Void)
    @available(*, noasync)
    public func whenComplete(_ callback: @escaping (Swift.Result<Value, any Swift.Error>) -> Swift.Void)
    @available(*, noasync)
    public func always(_ callback: @escaping (Swift.Result<Value, any Swift.Error>) -> Swift.Void) -> NIOCore.EventLoopFuture<Value>.Isolated
    @available(*, noasync)
    public func unwrap<NewValue>(orReplace replacement: NewValue) -> NIOCore.EventLoopFuture<NewValue>.Isolated where Value == NewValue?
    @available(*, noasync)
    public func unwrap<NewValue>(orElse callback: @escaping () -> NewValue) -> NIOCore.EventLoopFuture<NewValue>.Isolated where Value == NewValue?
    public func nonisolated() -> NIOCore.EventLoopFuture<Value>
  }
  @available(*, noasync)
  final public func assumeIsolated() -> NIOCore.EventLoopFuture<Value>.Isolated
  @available(*, noasync)
  final public func assumeIsolatedUnsafeUnchecked() -> NIOCore.EventLoopFuture<Value>.Isolated
}
@available(*, unavailable)
extension NIOCore.EventLoopFuture.Isolated : Swift.Sendable {
}
extension NIOCore.EventLoopPromise {
  public struct Isolated {
    @available(*, noasync)
    public var futureResult: NIOCore.EventLoopFuture<Value>.Isolated {
      get
    }
    @available(*, noasync)
    public func succeed(_ value: Value)
    @available(*, noasync)
    public func completeWith(_ result: Swift.Result<Value, any Swift.Error>)
    public func nonisolated() -> NIOCore.EventLoopPromise<Value>
  }
  @available(*, noasync)
  public func assumeIsolated() -> NIOCore.EventLoopPromise<Value>.Isolated
  public func assumeIsolatedUnsafeUnchecked() -> NIOCore.EventLoopPromise<Value>.Isolated
}
@available(*, unavailable)
extension NIOCore.EventLoopPromise.Isolated : Swift.Sendable {
}
extension NIOCore.EventLoopFuture {
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  @preconcurrency final public func flatMap<NewValue>(file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ callback: @escaping @Sendable (Value) -> NIOCore.EventLoopFuture<NewValue>) -> NIOCore.EventLoopFuture<NewValue> where NewValue : Swift.Sendable
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  @preconcurrency final public func flatMapThrowing<NewValue>(file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ callback: @escaping @Sendable (Value) throws -> NewValue) -> NIOCore.EventLoopFuture<NewValue> where NewValue : Swift.Sendable
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  final public func flatMapErrorThrowing(file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ callback: @escaping @Sendable (any Swift.Error) throws -> Value) -> NIOCore.EventLoopFuture<Value>
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  final public func map<NewValue>(file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ callback: @escaping @Sendable (Value) -> (NewValue)) -> NIOCore.EventLoopFuture<NewValue>
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  final public func flatMapError(file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ callback: @escaping @Sendable (any Swift.Error) -> NIOCore.EventLoopFuture<Value>) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  @preconcurrency final public func flatMapResult<NewValue, SomeError>(file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ body: @escaping @Sendable (Value) -> Swift.Result<NewValue, SomeError>) -> NIOCore.EventLoopFuture<NewValue> where SomeError : Swift.Error
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  @preconcurrency final public func recover(file: Swift.StaticString = #fileID, line: Swift.UInt = #line, _ callback: @escaping @Sendable (any Swift.Error) -> Value) -> NIOCore.EventLoopFuture<Value>
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  @preconcurrency final public func and<OtherValue>(_ other: NIOCore.EventLoopFuture<OtherValue>, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<(Value, OtherValue)> where OtherValue : Swift.Sendable
  @available(*, deprecated, message: "Please don't pass file:line:, there's no point.")
  @preconcurrency final public func and<OtherValue>(value: OtherValue, file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<(Value, OtherValue)> where OtherValue : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func flatMapWithEventLoop<NewValue>(_ callback: @escaping @Sendable (Value, any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<NewValue>) -> NIOCore.EventLoopFuture<NewValue> where NewValue : Swift.Sendable
  @preconcurrency final public func flatMapErrorWithEventLoop(_ callback: @escaping @Sendable (any Swift.Error, any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<Value>) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable
  @preconcurrency final public func foldWithEventLoop<OtherValue>(_ futures: [NIOCore.EventLoopFuture<OtherValue>], with combiningFunction: @escaping @Sendable (Value, OtherValue, any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<Value>) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable, OtherValue : Swift.Sendable
}
public struct EventLoopPromise<Value> {
  public let futureResult: NIOCore.EventLoopFuture<Value>
  @preconcurrency public func succeed(_ value: Value) where Value : Swift.Sendable
  public func fail(_ error: any Swift.Error)
  @preconcurrency public func completeWith(_ future: NIOCore.EventLoopFuture<Value>) where Value : Swift.Sendable
  @preconcurrency public func completeWith(_ result: Swift.Result<Value, any Swift.Error>) where Value : Swift.Sendable
}
extension NIOCore.EventLoopPromise : Swift.Equatable {
  public static func == (a: NIOCore.EventLoopPromise<Value>, b: NIOCore.EventLoopPromise<Value>) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class EventLoopFuture<Value> {
  final public let eventLoop: any NIOCore.EventLoop
  @objc deinit
}
extension NIOCore.EventLoopFuture : Swift.Equatable {
  public static func == (lhs: NIOCore.EventLoopFuture<Value>, rhs: NIOCore.EventLoopFuture<Value>) -> Swift.Bool
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func flatMap<NewValue>(_ callback: @escaping @Sendable (Value) -> NIOCore.EventLoopFuture<NewValue>) -> NIOCore.EventLoopFuture<NewValue> where NewValue : Swift.Sendable
  @preconcurrency final public func flatMapThrowing<NewValue>(_ callback: @escaping @Sendable (Value) throws -> NewValue) -> NIOCore.EventLoopFuture<NewValue>
  @preconcurrency final public func flatMapErrorThrowing(_ callback: @escaping @Sendable (any Swift.Error) throws -> Value) -> NIOCore.EventLoopFuture<Value>
  @preconcurrency final public func map<NewValue>(_ callback: @escaping @Sendable (Value) -> (NewValue)) -> NIOCore.EventLoopFuture<NewValue>
  @preconcurrency final public func flatMapError(_ callback: @escaping @Sendable (any Swift.Error) -> NIOCore.EventLoopFuture<Value>) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable
  @preconcurrency final public func flatMapResult<NewValue, SomeError>(_ body: @escaping @Sendable (Value) -> Swift.Result<NewValue, SomeError>) -> NIOCore.EventLoopFuture<NewValue> where SomeError : Swift.Error
  @preconcurrency final public func recover(_ callback: @escaping @Sendable (any Swift.Error) -> Value) -> NIOCore.EventLoopFuture<Value>
  @preconcurrency final public func whenSuccess(_ callback: @escaping @Sendable (Value) -> Swift.Void)
  @preconcurrency final public func whenFailure(_ callback: @escaping @Sendable (any Swift.Error) -> Swift.Void)
  @preconcurrency final public func whenComplete(_ callback: @escaping @Sendable (Swift.Result<Value, any Swift.Error>) -> Swift.Void)
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func and<OtherValue>(_ other: NIOCore.EventLoopFuture<OtherValue>) -> NIOCore.EventLoopFuture<(Value, OtherValue)> where OtherValue : Swift.Sendable
  @preconcurrency final public func and<OtherValue>(value: OtherValue) -> NIOCore.EventLoopFuture<(Value, OtherValue)> where OtherValue : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func cascade(to promise: NIOCore.EventLoopPromise<Value>?) where Value : Swift.Sendable
  @preconcurrency final public func cascadeSuccess(to promise: NIOCore.EventLoopPromise<Value>?) where Value : Swift.Sendable
  final public func cascadeFailure<NewValue>(to promise: NIOCore.EventLoopPromise<NewValue>?)
}
extension NIOCore.EventLoopFuture {
  @available(*, noasync, renamed: "get()", message: "wait() can block indefinitely, prefer get()")
  @preconcurrency final public func wait(file: Swift.StaticString = #file, line: Swift.UInt = #line) throws -> Value where Value : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func fold<OtherValue>(_ futures: [NIOCore.EventLoopFuture<OtherValue>], with combiningFunction: @escaping @Sendable (Value, OtherValue) -> NIOCore.EventLoopFuture<Value>) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable, OtherValue : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  @preconcurrency public static func reduce<InputValue>(_ initialResult: Value, _ futures: [NIOCore.EventLoopFuture<InputValue>], on eventLoop: any NIOCore.EventLoop, _ nextPartialResult: @escaping @Sendable (Value, InputValue) -> Value) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable, InputValue : Swift.Sendable
  @preconcurrency public static func reduce<InputValue>(into initialResult: Value, _ futures: [NIOCore.EventLoopFuture<InputValue>], on eventLoop: any NIOCore.EventLoop, _ updateAccumulatingResult: @escaping @Sendable (inout Value, InputValue) -> Swift.Void) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable, InputValue : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  public static func andAllSucceed(_ futures: [NIOCore.EventLoopFuture<Value>], on eventLoop: any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<Swift.Void>
  public static func andAllSucceed(_ futures: [NIOCore.EventLoopFuture<Value>], promise: NIOCore.EventLoopPromise<Swift.Void>)
  @preconcurrency public static func whenAllSucceed(_ futures: [NIOCore.EventLoopFuture<Value>], on eventLoop: any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<[Value]> where Value : Swift.Sendable
  @preconcurrency public static func whenAllSucceed(_ futures: [NIOCore.EventLoopFuture<Value>], promise: NIOCore.EventLoopPromise<[Value]>) where Value : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  public static func andAllComplete(_ futures: [NIOCore.EventLoopFuture<Value>], on eventLoop: any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<Swift.Void>
  public static func andAllComplete(_ futures: [NIOCore.EventLoopFuture<Value>], promise: NIOCore.EventLoopPromise<Swift.Void>)
  @preconcurrency public static func whenAllComplete(_ futures: [NIOCore.EventLoopFuture<Value>], on eventLoop: any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<[Swift.Result<Value, any Swift.Error>]> where Value : Swift.Sendable
  @preconcurrency public static func whenAllComplete(_ futures: [NIOCore.EventLoopFuture<Value>], promise: NIOCore.EventLoopPromise<[Swift.Result<Value, any Swift.Error>]>) where Value : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func hop(to target: any NIOCore.EventLoop) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func always(_ callback: @escaping @Sendable (Swift.Result<Value, any Swift.Error>) -> Swift.Void) -> NIOCore.EventLoopFuture<Value>
}
extension NIOCore.EventLoopFuture {
  final public func unwrap<NewValue>(orError: any Swift.Error) -> NIOCore.EventLoopFuture<NewValue> where Value == NewValue?
  @preconcurrency final public func unwrap<NewValue>(orReplace replacement: NewValue) -> NIOCore.EventLoopFuture<NewValue> where Value == NewValue?, NewValue : Swift.Sendable
  @preconcurrency final public func unwrap<NewValue>(orElse callback: @escaping @Sendable () -> NewValue) -> NIOCore.EventLoopFuture<NewValue> where Value == NewValue?
}
extension NIOCore.EventLoopFuture {
  @preconcurrency final public func flatMapBlocking<NewValue>(onto queue: Dispatch.DispatchQueue, _ callbackMayBlock: @escaping @Sendable (Value) throws -> NewValue) -> NIOCore.EventLoopFuture<NewValue> where Value : Swift.Sendable, NewValue : Swift.Sendable
  @preconcurrency final public func whenSuccessBlocking(onto queue: Dispatch.DispatchQueue, _ callbackMayBlock: @escaping @Sendable (Value) -> Swift.Void) where Value : Swift.Sendable
  @preconcurrency final public func whenFailureBlocking(onto queue: Dispatch.DispatchQueue, _ callbackMayBlock: @escaping @Sendable (any Swift.Error) -> Swift.Void)
  @preconcurrency final public func whenCompleteBlocking(onto queue: Dispatch.DispatchQueue, _ callbackMayBlock: @escaping @Sendable (Swift.Result<Value, any Swift.Error>) -> Swift.Void) where Value : Swift.Sendable
}
extension NIOCore.EventLoopFuture {
  final public func assertSuccess(file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Value>
  final public func assertFailure(file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Value>
  final public func preconditionSuccess(file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Value>
  final public func preconditionFailure(file: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> NIOCore.EventLoopFuture<Value>
}
public struct _NIOEventLoopFutureIdentifier : Swift.Hashable, Swift.Sendable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NIOCore._NIOEventLoopFutureIdentifier, b: NIOCore._NIOEventLoopFutureIdentifier) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.EventLoopPromise : Swift.Sendable {
}
extension NIOCore.EventLoopFuture : @unchecked Swift.Sendable {
}
extension NIOCore.EventLoopPromise where Value == () {
  public func succeed()
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional {
  @preconcurrency public mutating func setOrCascade<Value>(to promise: NIOCore.EventLoopPromise<Value>?) where Wrapped == NIOCore.EventLoopPromise<Value>, Value : Swift.Sendable
}
#else
extension Swift.Optional {
  @preconcurrency public mutating func setOrCascade<Value>(to promise: NIOCore.EventLoopPromise<Value>?) where Wrapped == NIOCore.EventLoopPromise<Value>, Value : Swift.Sendable
}
#endif
public protocol FileDescriptor {
  func withUnsafeFileDescriptor<T>(_ body: (Swift.CInt) throws -> T) throws -> T
  var isOpen: Swift.Bool { get }
  func close() throws
}
public typealias NIOPOSIXFileMode = sys_types.mode_t
final public class NIOFileHandle : NIOCore.FileDescriptor & Swift.Sendable {
  final public var isOpen: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Avoid using NIOFileHandle. The type is difficult to hold correctly, use NIOFileSystem as a replacement API.")
  convenience public init(descriptor: Swift.CInt)
  public init(_deprecatedTakingOwnershipOfDescriptor descriptor: Swift.CInt)
  @objc deinit
  final public func duplicate() throws -> NIOCore.NIOFileHandle
  final public func takeDescriptorOwnership() throws -> Swift.CInt
  final public func close() throws
  final public func withUnsafeFileDescriptor<T>(_ body: (Swift.CInt) throws -> T) throws -> T
}
extension NIOCore.NIOFileHandle {
  public struct Mode : Swift.OptionSet, Swift.Sendable {
    public let rawValue: Swift.UInt8
    public init(rawValue: Swift.UInt8)
    public static let read: NIOCore.NIOFileHandle.Mode
    public static let write: NIOCore.NIOFileHandle.Mode
    public typealias ArrayLiteralElement = NIOCore.NIOFileHandle.Mode
    public typealias Element = NIOCore.NIOFileHandle.Mode
    public typealias RawValue = Swift.UInt8
  }
  public struct Flags : Swift.Sendable {
    public static let `default`: NIOCore.NIOFileHandle.Flags
    public static let defaultPermissions: sys_types.mode_t
    public static func allowFileCreation(posixMode: NIOCore.NIOPOSIXFileMode = defaultPermissions) -> NIOCore.NIOFileHandle.Flags
    public static func posix(flags: Swift.CInt, mode: NIOCore.NIOPOSIXFileMode) -> NIOCore.NIOFileHandle.Flags
  }
  @available(*, deprecated, message: "Avoid using NIOFileHandle. The type is difficult to hold correctly, use NIOFileSystem as a replacement API.")
  convenience public init(path: Swift.String, mode: NIOCore.NIOFileHandle.Mode = .read, flags: NIOCore.NIOFileHandle.Flags = .default) throws
  @available(*, noasync, message: "This method may block the calling thread")
  convenience public init(_deprecatedPath path: Swift.String, mode: NIOCore.NIOFileHandle.Mode = .read, flags: NIOCore.NIOFileHandle.Flags = .default) throws
  @available(*, deprecated, message: "Avoid using NIOFileHandle. The type is difficult to hold correctly, use NIOFileSystem as a replacement API.")
  convenience public init(path: Swift.String) throws
  @available(*, noasync, message: "This method may block the calling thread")
  convenience public init(_deprecatedPath path: Swift.String) throws
}
extension NIOCore.NIOFileHandle : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
public struct FileRegion : Swift.Sendable {
  public let fileHandle: NIOCore.NIOFileHandle
  public var readerIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public init(fileHandle: NIOCore.NIOFileHandle, readerIndex: Swift.Int, endIndex: Swift.Int)
  public var readableBytes: Swift.Int {
    get
  }
  public mutating func moveReaderIndex(forwardBy offset: Swift.Int)
}
extension NIOCore.FileRegion {
  public init(fileHandle: NIOCore.NIOFileHandle) throws
}
extension NIOCore.FileRegion : Swift.Equatable {
  public static func == (lhs: NIOCore.FileRegion, rhs: NIOCore.FileRegion) -> Swift.Bool
}
extension NIOCore.FileRegion : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum NIOSingletons {
}
extension NIOCore.NIOSingletons {
  public static var groupLoopCountSuggestion: Swift.Int {
    get
    set
  }
  public static var blockingPoolThreadCountSuggestion: Swift.Int {
    get
    set
  }
  public static var singletonsEnabledSuggestion: Swift.Bool {
    get
    set
  }
}
public struct IOError : Swift.Error {
  @available(*, deprecated, message: "NIO no longer uses FailureDescription.")
  public enum FailureDescription {
    case function(Swift.StaticString)
    case reason(Swift.String)
  }
  @available(*, deprecated, message: "NIO no longer uses FailureDescription, use IOError.description for a human-readable error description")
  public var reason: NIOCore.IOError.FailureDescription {
    get
  }
  public var errnoCode: Swift.CInt {
    get
  }
  public init(errnoCode: Swift.CInt, reason: Swift.String)
  @available(*, deprecated, renamed: "init(errnoCode:reason:)")
  public init(errnoCode: Swift.CInt, function: Swift.StaticString)
}
extension NIOCore.IOError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
}
public enum IOData : Swift.Sendable {
  case byteBuffer(NIOCore.ByteBuffer)
  case fileRegion(NIOCore.FileRegion)
}
extension NIOCore.IOData : Swift.Equatable {
  public static func == (a: NIOCore.IOData, b: NIOCore.IOData) -> Swift.Bool
}
extension NIOCore.IOData {
  public var readableBytes: Swift.Int {
    get
  }
  public mutating func moveReaderIndex(forwardBy: Swift.Int)
}
extension NIOCore.IOData : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct NIOIPProtocol : Swift.RawRepresentable, Swift.Hashable, Swift.Sendable {
  public typealias RawValue = Swift.UInt8
  public var rawValue: NIOCore.NIOIPProtocol.RawValue
  public init(rawValue: NIOCore.NIOIPProtocol.RawValue)
}
extension NIOCore.NIOIPProtocol {
  public init(_ rawValue: Swift.Int)
}
extension NIOCore.NIOIPProtocol {
  public static let hopopt: NIOCore.NIOIPProtocol
  public static let icmp: NIOCore.NIOIPProtocol
  public static let igmp: NIOCore.NIOIPProtocol
  public static let ggp: NIOCore.NIOIPProtocol
  public static let ipv4: NIOCore.NIOIPProtocol
  public static let st: NIOCore.NIOIPProtocol
  public static let tcp: NIOCore.NIOIPProtocol
  public static let egp: NIOCore.NIOIPProtocol
  public static let nvpIi: NIOCore.NIOIPProtocol
  public static let udp: NIOCore.NIOIPProtocol
  public static let hmp: NIOCore.NIOIPProtocol
  public static let rdp: NIOCore.NIOIPProtocol
  public static let irtp: NIOCore.NIOIPProtocol
  public static let isoTp4: NIOCore.NIOIPProtocol
  public static let netblt: NIOCore.NIOIPProtocol
  public static let dccp: NIOCore.NIOIPProtocol
  public static let ipv6: NIOCore.NIOIPProtocol
  public static let rsvp: NIOCore.NIOIPProtocol
  public static let gre: NIOCore.NIOIPProtocol
  public static let dsr: NIOCore.NIOIPProtocol
  public static let esp: NIOCore.NIOIPProtocol
  public static let ah: NIOCore.NIOIPProtocol
  public static let narp: NIOCore.NIOIPProtocol
  public static let ipv6Icmp: NIOCore.NIOIPProtocol
  public static let ipv6Nonxt: NIOCore.NIOIPProtocol
  public static let ipv6Opts: NIOCore.NIOIPProtocol
  public static let eigrp: NIOCore.NIOIPProtocol
  public static let ospfigp: NIOCore.NIOIPProtocol
  public static let etherip: NIOCore.NIOIPProtocol
  public static let encap: NIOCore.NIOIPProtocol
  public static let pim: NIOCore.NIOIPProtocol
  public static let ipcomp: NIOCore.NIOIPProtocol
  public static let vrrp: NIOCore.NIOIPProtocol
  public static let l2tp: NIOCore.NIOIPProtocol
  public static let fc: NIOCore.NIOIPProtocol
  public static let manet: NIOCore.NIOIPProtocol
  public static let hip: NIOCore.NIOIPProtocol
  public static let shim6: NIOCore.NIOIPProtocol
  public static let wesp: NIOCore.NIOIPProtocol
  public static let rohc: NIOCore.NIOIPProtocol
  public static let ethernet: NIOCore.NIOIPProtocol
  public static let aggfrag: NIOCore.NIOIPProtocol
}
extension NIOCore.NIOIPProtocol : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(*, deprecated, renamed: "NIONetworkDevice")
final public class NIONetworkInterface : Swift.Sendable {
  final public let name: Swift.String
  final public let address: NIOCore.SocketAddress
  final public let netmask: NIOCore.SocketAddress?
  final public let broadcastAddress: NIOCore.SocketAddress?
  final public let pointToPointDestinationAddress: NIOCore.SocketAddress?
  final public let multicastSupported: Swift.Bool
  final public let interfaceIndex: Swift.Int
  @objc deinit
}
@available(*, deprecated, renamed: "NIONetworkDevice")
extension NIOCore.NIONetworkInterface : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
@available(*, deprecated, renamed: "NIONetworkDevice")
extension NIOCore.NIONetworkInterface : Swift.Equatable {
  public static func == (lhs: NIOCore.NIONetworkInterface, rhs: NIOCore.NIONetworkInterface) -> Swift.Bool
}
public struct NIONetworkDevice {
  public var name: Swift.String {
    get
    set
  }
  public var address: NIOCore.SocketAddress? {
    get
    set
  }
  public var netmask: NIOCore.SocketAddress? {
    get
    set
  }
  public var broadcastAddress: NIOCore.SocketAddress? {
    get
    set
  }
  public var pointToPointDestinationAddress: NIOCore.SocketAddress? {
    get
    set
  }
  public var multicastSupported: Swift.Bool {
    get
    set
  }
  public var interfaceIndex: Swift.Int {
    get
    set
  }
  @available(*, deprecated, message: "This is a compatibility helper, and will be removed in a future release")
  public init(_ interface: NIOCore.NIONetworkInterface)
  public init(name: Swift.String, address: NIOCore.SocketAddress?, netmask: NIOCore.SocketAddress?, broadcastAddress: NIOCore.SocketAddress?, pointToPointDestinationAddress: NIOCore.SocketAddress, multicastSupported: Swift.Bool, interfaceIndex: Swift.Int)
}
extension NIOCore.NIONetworkDevice : @unchecked Swift.Sendable {
}
extension NIOCore.NIONetworkDevice : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NIOCore.NIONetworkDevice : Swift.Equatable {
  public static func == (lhs: NIOCore.NIONetworkDevice, rhs: NIOCore.NIONetworkDevice) -> Swift.Bool
}
extension NIOCore.NIONetworkDevice : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct MarkedCircularBuffer<Element> : Swift.CustomStringConvertible {
  public init(initialCapacity: Swift.Int)
  public mutating func append(_ value: Element)
  public mutating func removeFirst() -> Element
  public mutating func popFirst() -> Element?
  public var first: Element? {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public mutating func mark()
  public func isMarked(index: NIOCore.MarkedCircularBuffer<Element>.Index) -> Swift.Bool
  public var markedElementIndex: NIOCore.MarkedCircularBuffer<Element>.Index? {
    get
  }
  public var markedElement: Element? {
    get
  }
  public var hasMark: Swift.Bool {
    get
  }
}
extension NIOCore.MarkedCircularBuffer : Swift.Collection, Swift.MutableCollection {
  public typealias RangeType<Bound> = Swift.Range<Bound> where Bound : Swift.Strideable, Bound.Stride : Swift.SignedInteger
  public typealias Index = NIOCore.CircularBuffer<Element>.Index
  public typealias SubSequence = NIOCore.CircularBuffer<Element>
  public func index(after i: NIOCore.MarkedCircularBuffer<Element>.Index) -> NIOCore.MarkedCircularBuffer<Element>.Index
  public var startIndex: NIOCore.MarkedCircularBuffer<Element>.Index {
    get
  }
  public var endIndex: NIOCore.MarkedCircularBuffer<Element>.Index {
    get
  }
  public subscript(index: NIOCore.MarkedCircularBuffer<Element>.Index) -> Element {
    get
    set
  }
  public subscript(bounds: Swift.Range<NIOCore.MarkedCircularBuffer<Element>.Index>) -> NIOCore.MarkedCircularBuffer<Element>.SubSequence {
    get
    set
  }
  public typealias Indices = Swift.DefaultIndices<NIOCore.MarkedCircularBuffer<Element>>
  public typealias Iterator = Swift.IndexingIterator<NIOCore.MarkedCircularBuffer<Element>>
}
extension NIOCore.MarkedCircularBuffer : Swift.RandomAccessCollection {
  public func index(_ i: NIOCore.MarkedCircularBuffer<Element>.Index, offsetBy distance: Swift.Int) -> NIOCore.MarkedCircularBuffer<Element>.Index
  public func distance(from start: NIOCore.MarkedCircularBuffer<Element>.Index, to end: NIOCore.MarkedCircularBuffer<Element>.Index) -> Swift.Int
  public func index(before i: NIOCore.MarkedCircularBuffer<Element>.Index) -> NIOCore.MarkedCircularBuffer<Element>.Index
}
extension NIOCore.MarkedCircularBuffer : Swift.Sendable where Element : Swift.Sendable {
}
public protocol MulticastChannel : NIOCore.Channel {
  func joinGroup(_ group: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @available(*, deprecated, renamed: "joinGroup(_:device:promise:)")
  func joinGroup(_ group: NIOCore.SocketAddress, interface: NIOCore.NIONetworkInterface?, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func joinGroup(_ group: NIOCore.SocketAddress, device: NIOCore.NIONetworkDevice?, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func leaveGroup(_ group: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  @available(*, deprecated, renamed: "leaveGroup(_:device:promise:)")
  func leaveGroup(_ group: NIOCore.SocketAddress, interface: NIOCore.NIONetworkInterface?, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  func leaveGroup(_ group: NIOCore.SocketAddress, device: NIOCore.NIONetworkDevice?, promise: NIOCore.EventLoopPromise<Swift.Void>?)
}
extension NIOCore.MulticastChannel {
  public func joinGroup(_ group: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func joinGroup(_ group: NIOCore.SocketAddress) -> NIOCore.EventLoopFuture<Swift.Void>
  @available(*, deprecated, renamed: "joinGroup(_:device:)")
  public func joinGroup(_ group: NIOCore.SocketAddress, interface: NIOCore.NIONetworkInterface?) -> NIOCore.EventLoopFuture<Swift.Void>
  public func joinGroup(_ group: NIOCore.SocketAddress, device: NIOCore.NIONetworkDevice?) -> NIOCore.EventLoopFuture<Swift.Void>
  public func leaveGroup(_ group: NIOCore.SocketAddress, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func leaveGroup(_ group: NIOCore.SocketAddress) -> NIOCore.EventLoopFuture<Swift.Void>
  @available(*, deprecated, renamed: "leaveGroup(_:device:)")
  public func leaveGroup(_ group: NIOCore.SocketAddress, interface: NIOCore.NIONetworkInterface?) -> NIOCore.EventLoopFuture<Swift.Void>
  public func leaveGroup(_ group: NIOCore.SocketAddress, device: NIOCore.NIONetworkDevice?) -> NIOCore.EventLoopFuture<Swift.Void>
}
extension NIOCore.MulticastChannel {
  public func joinGroup(_ group: NIOCore.SocketAddress, device: NIOCore.NIONetworkDevice?, promise: NIOCore.EventLoopPromise<Swift.Void>?)
  public func leaveGroup(_ group: NIOCore.SocketAddress, device: NIOCore.NIONetworkDevice?, promise: NIOCore.EventLoopPromise<Swift.Void>?)
}
public struct NIOMulticastNotSupportedError : Swift.Error {
  public var device: NIOCore.NIONetworkDevice
  public init(device: NIOCore.NIONetworkDevice)
}
public struct NIOMulticastNotImplementedError : Swift.Error {
  public init()
}
public struct NIOAny {
  public init<T>(_ value: T)
}
@available(*, unavailable)
extension NIOCore.NIOAny : Swift.Sendable {
}
extension NIOCore.NIOAny : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NIOCore.NIOAny : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
final public class NIOCloseOnErrorHandler : NIOCore.ChannelInboundHandler, Swift.Sendable {
  public typealias InboundIn = NIOCore.NIOAny
  public init()
  final public func errorCaught(context: NIOCore.ChannelHandlerContext, error: any Swift.Error)
  public typealias InboundOut = Swift.Never
  public typealias OutboundOut = Swift.Never
  @objc deinit
}
public struct NIOLoopBound<Value> : @unchecked Swift.Sendable {
  public let eventLoop: any NIOCore.EventLoop
  @available(*, deprecated, renamed: "eventLoop")
  public var _eventLoop: any NIOCore.EventLoop {
    get
  }
  public init(_ value: Value, eventLoop: any NIOCore.EventLoop)
  public var value: Value {
    get
    _modify
  }
}
@_hasMissingDesignatedInitializers final public class NIOLoopBoundBox<Value> : @unchecked Swift.Sendable {
  final public let eventLoop: any NIOCore.EventLoop
  @available(*, deprecated, renamed: "eventLoop")
  final public var _eventLoop: any NIOCore.EventLoop {
    get
  }
  convenience public init(_ value: Value, eventLoop: any NIOCore.EventLoop)
  public static func makeEmptyBox<NonOptionalValue>(valueType: NonOptionalValue.Type = NonOptionalValue.self, eventLoop: any NIOCore.EventLoop) -> NIOCore.NIOLoopBoundBox<Value> where Value == NonOptionalValue?
  public static func makeBoxSendingValue(_ value: Value, as: Value.Type = Value.self, eventLoop: any NIOCore.EventLoop) -> NIOCore.NIOLoopBoundBox<Value> where Value : Swift.Sendable
  #if compiler(>=5.3) && $SendingArgsAndResults
  public static func makeBoxSendingValue(_ value: sending Value, as: Value.Type = Value.self, eventLoop: any NIOCore.EventLoop) -> NIOCore.NIOLoopBoundBox<Value>
  #else
  public static func makeBoxSendingValue(_ value: __owned Value, as: Value.Type = Value.self, eventLoop: any NIOCore.EventLoop) -> NIOCore.NIOLoopBoundBox<Value>
  #endif
  final public var value: Value {
    get
    _modify
  }
  @objc deinit
}
public protocol NIOScheduledCallbackHandler {
  func handleScheduledCallback(eventLoop: some EventLoop)
  func didCancelScheduledCallback(eventLoop: some EventLoop)
}
extension NIOCore.NIOScheduledCallbackHandler {
  public func didCancelScheduledCallback(eventLoop: some EventLoop)
}
public struct NIOScheduledCallback : Swift.Sendable {
  public init(_ eventLoop: any NIOCore.EventLoop, id: Swift.UInt64)
  public func cancel()
  public var customCallbackID: Swift.UInt64? {
    get
  }
}
extension NIOCore.EventLoop {
  @preconcurrency public func _scheduleCallback(at deadline: NIOCore.NIODeadline, handler: some (NIOScheduledCallbackHandler & Sendable)) -> NIOCore.NIOScheduledCallback
  @discardableResult
  @preconcurrency public func scheduleCallback(at deadline: NIOCore.NIODeadline, handler: some (NIOScheduledCallbackHandler & Sendable)) -> NIOCore.NIOScheduledCallback
  @discardableResult
  @preconcurrency public func scheduleCallback(in amount: NIOCore.TimeAmount, handler: some (NIOScheduledCallbackHandler & Sendable)) throws -> NIOCore.NIOScheduledCallback
  public func cancelScheduledCallback(_ scheduledCallback: NIOCore.NIOScheduledCallback)
}
@available(*, deprecated, renamed: "Sendable")
public typealias NIOSendable = Swift.Sendable
@preconcurrency public protocol _NIOPreconcurrencySendable : Swift.Sendable {
}
@available(*, deprecated, message: "use @preconcurrency and Sendable directly")
public typealias NIOPreconcurrencySendable = NIOCore._NIOPreconcurrencySendable
public protocol RecvByteBufferAllocator : NIOCore._NIOPreconcurrencySendable {
  func buffer(allocator: NIOCore.ByteBufferAllocator) -> NIOCore.ByteBuffer
  func nextBufferSize() -> Swift.Int?
  mutating func record(actualReadBytes: Swift.Int) -> Swift.Bool
}
extension NIOCore.RecvByteBufferAllocator {
  public func nextBufferSize() -> Swift.Int?
}
public struct FixedSizeRecvByteBufferAllocator : NIOCore.RecvByteBufferAllocator {
  public let capacity: Swift.Int
  public init(capacity: Swift.Int)
  public mutating func record(actualReadBytes: Swift.Int) -> Swift.Bool
  public func buffer(allocator: NIOCore.ByteBufferAllocator) -> NIOCore.ByteBuffer
}
extension NIOCore.FixedSizeRecvByteBufferAllocator {
  public func nextBufferSize() -> Swift.Int?
}
public struct AdaptiveRecvByteBufferAllocator : NIOCore.RecvByteBufferAllocator {
  public let minimum: Swift.Int
  public let maximum: Swift.Int
  public let initial: Swift.Int
  public init()
  public init(minimum: Swift.Int, initial: Swift.Int, maximum: Swift.Int)
  public func buffer(allocator: NIOCore.ByteBufferAllocator) -> NIOCore.ByteBuffer
  public mutating func record(actualReadBytes: Swift.Int) -> Swift.Bool
}
extension NIOCore.AdaptiveRecvByteBufferAllocator {
  public func nextBufferSize() -> Swift.Int?
}
public protocol NIOSingleStepByteToMessageDecoder : NIOCore.ByteToMessageDecoder {
  associatedtype InboundOut
  mutating func decode(buffer: inout NIOCore.ByteBuffer) throws -> Self.InboundOut?
  mutating func decodeLast(buffer: inout NIOCore.ByteBuffer, seenEOF: Swift.Bool) throws -> Self.InboundOut?
}
extension NIOCore.NIOSingleStepByteToMessageDecoder {
  public mutating func decode(context: NIOCore.ChannelHandlerContext, buffer: inout NIOCore.ByteBuffer) throws -> NIOCore.DecodingState
  public mutating func decodeLast(context: NIOCore.ChannelHandlerContext, buffer: inout NIOCore.ByteBuffer, seenEOF: Swift.Bool) throws -> NIOCore.DecodingState
}
final public class NIOSingleStepByteToMessageProcessor<Decoder> where Decoder : NIOCore.NIOSingleStepByteToMessageDecoder {
  public init(_ decoder: Decoder, maximumBufferSize: Swift.Int? = nil)
  @objc deinit
}
@available(*, unavailable)
extension NIOCore.NIOSingleStepByteToMessageProcessor : Swift.Sendable {
}
extension NIOCore.NIOSingleStepByteToMessageProcessor {
  final public var unprocessedBytes: Swift.Int {
    get
  }
  final public func process(buffer: NIOCore.ByteBuffer, _ messageReceiver: (Decoder.InboundOut) throws -> Swift.Void) throws
  final public func finishProcessing(seenEOF: Swift.Bool, _ messageReceiver: (Decoder.InboundOut) throws -> Swift.Void) throws
}
public enum SocketAddressError : Swift.Error, Swift.Equatable, Swift.Hashable {
  case unknown(host: Swift.String, port: Swift.Int)
  case unsupported
  case unixDomainSocketPathTooLong
  case failedToParseIPString(Swift.String)
  public static func == (a: NIOCore.SocketAddressError, b: NIOCore.SocketAddressError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.SocketAddressError {
  public struct FailedToParseIPByteBuffer : Swift.Error, Swift.Hashable {
    public var address: NIOCore.ByteBuffer
    public init(address: NIOCore.ByteBuffer)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: NIOCore.SocketAddressError.FailedToParseIPByteBuffer, b: NIOCore.SocketAddressError.FailedToParseIPByteBuffer) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public enum SocketAddress : Swift.CustomStringConvertible, Swift.Sendable {
  public struct IPv4Address {
    public var address: Darwin.sockaddr_in {
      get
    }
    public var host: Swift.String {
      get
    }
  }
  public struct IPv6Address {
    public var address: Darwin.sockaddr_in6 {
      get
    }
    public var host: Swift.String {
      get
    }
  }
  public struct UnixSocketAddress : Swift.Sendable {
    public var address: Darwin.sockaddr_un {
      get
    }
  }
  case v4(NIOCore.SocketAddress.IPv4Address)
  case v6(NIOCore.SocketAddress.IPv6Address)
  case unixDomainSocket(NIOCore.SocketAddress.UnixSocketAddress)
  public var description: Swift.String {
    get
  }
  @available(*, deprecated, renamed: "SocketAddress.protocol")
  public var protocolFamily: Swift.Int32 {
    get
  }
  public var `protocol`: NIOCore.NIOBSDSocket.ProtocolFamily {
    get
  }
  public var ipAddress: Swift.String? {
    get
  }
  public var port: Swift.Int? {
    get
    set
  }
  public var pathname: Swift.String? {
    get
  }
  public func withSockAddr<T>(_ body: (Swift.UnsafePointer<Darwin.sockaddr>, Swift.Int) throws -> T) rethrows -> T
  public init(_ addr: Darwin.sockaddr_in, host: Swift.String)
  public init(_ addr: Darwin.sockaddr_in6, host: Swift.String)
  public init(_ addr: Darwin.sockaddr_in)
  public init(_ addr: Darwin.sockaddr_in6)
  public init(_ addr: Darwin.sockaddr_un)
  public init(unixDomainSocketPath: Swift.String) throws
  public init(ipAddress: Swift.String, port: Swift.Int) throws
  public init(packedIPAddress: NIOCore.ByteBuffer, port: Swift.Int) throws
  public static func makeAddressResolvingHost(_ host: Swift.String, port: Swift.Int) throws -> NIOCore.SocketAddress
}
extension NIOCore.SocketAddress : Swift.Equatable {
  public static func == (lhs: NIOCore.SocketAddress, rhs: NIOCore.SocketAddress) -> Swift.Bool
}
extension NIOCore.SocketAddress.IPv4Address : Swift.Sendable {
}
extension NIOCore.SocketAddress.IPv6Address : Swift.Sendable {
}
extension NIOCore.SocketAddress : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension NIOCore.SocketAddress {
  public var isMulticast: Swift.Bool {
    get
  }
}
public protocol SocketOptionProvider : NIOCore._NIOPreconcurrencySendable {
  var eventLoop: any NIOCore.EventLoop { get }
  @preconcurrency func unsafeSetSocketOption<Value>(level: NIOCore.SocketOptionLevel, name: NIOCore.SocketOptionName, value: Value) -> NIOCore.EventLoopFuture<Swift.Void> where Value : Swift.Sendable
  @preconcurrency func unsafeSetSocketOption<Value>(level: NIOCore.NIOBSDSocket.OptionLevel, name: NIOCore.NIOBSDSocket.Option, value: Value) -> NIOCore.EventLoopFuture<Swift.Void> where Value : Swift.Sendable
  @preconcurrency func unsafeGetSocketOption<Value>(level: NIOCore.SocketOptionLevel, name: NIOCore.SocketOptionName) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable
  @preconcurrency func unsafeGetSocketOption<Value>(level: NIOCore.NIOBSDSocket.OptionLevel, name: NIOCore.NIOBSDSocket.Option) -> NIOCore.EventLoopFuture<Value> where Value : Swift.Sendable
}
public typealias NIOLinger = Darwin.linger
extension NIOCore.SocketOptionProvider {
  public func setSoLinger(_ value: Darwin.linger) -> NIOCore.EventLoopFuture<Swift.Void>
  public func getSoLinger() -> NIOCore.EventLoopFuture<NIOCore.NIOLinger>
  public func setIPMulticastIF(_ value: Darwin.in_addr) -> NIOCore.EventLoopFuture<Swift.Void>
  public func getIPMulticastIF() -> NIOCore.EventLoopFuture<Darwin.in_addr>
  public func setIPMulticastTTL(_ value: Swift.CUnsignedChar) -> NIOCore.EventLoopFuture<Swift.Void>
  public func getIPMulticastTTL() -> NIOCore.EventLoopFuture<Swift.CUnsignedChar>
  public func setIPMulticastLoop(_ value: Swift.CUnsignedChar) -> NIOCore.EventLoopFuture<Swift.Void>
  public func getIPMulticastLoop() -> NIOCore.EventLoopFuture<Swift.CUnsignedChar>
  public func setIPv6MulticastIF(_ value: Swift.CUnsignedInt) -> NIOCore.EventLoopFuture<Swift.Void>
  public func getIPv6MulticastIF() -> NIOCore.EventLoopFuture<Swift.CUnsignedInt>
  public func setIPv6MulticastHops(_ value: Swift.CInt) -> NIOCore.EventLoopFuture<Swift.Void>
  public func getIPv6MulticastHops() -> NIOCore.EventLoopFuture<Swift.CInt>
  public func setIPv6MulticastLoop(_ value: Swift.CUnsignedInt) -> NIOCore.EventLoopFuture<Swift.Void>
  public func getIPv6MulticastLoop() -> NIOCore.EventLoopFuture<Swift.CUnsignedInt>
  public func getTCPConnectionInfo() -> NIOCore.EventLoopFuture<Darwin.tcp_connection_info>
}
extension NIOCore.TimeAmount {
  @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
  public init(_ duration: Swift.Duration)
}
@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Swift.Duration {
  public init(_ timeAmount: NIOCore.TimeAmount)
}
public protocol _EmittingChannelHandler {
  associatedtype OutboundOut = Swift.Never
  func wrapOutboundOut(_ value: Self.OutboundOut) -> NIOCore.NIOAny
}
extension NIOCore._EmittingChannelHandler {
  public func wrapOutboundOut(_ value: Self.OutboundOut) -> NIOCore.NIOAny
  public static func wrapOutboundOut(_ value: Self.OutboundOut) -> NIOCore.NIOAny
}
public protocol ChannelInboundHandler : NIOCore._ChannelInboundHandler, NIOCore._EmittingChannelHandler {
  associatedtype InboundIn
  associatedtype InboundOut = Swift.Never
  func unwrapInboundIn(_ value: NIOCore.NIOAny) -> Self.InboundIn
  func wrapInboundOut(_ value: Self.InboundOut) -> NIOCore.NIOAny
}
extension NIOCore.ChannelInboundHandler {
  public func unwrapInboundIn(_ value: NIOCore.NIOAny) -> Self.InboundIn
  public func wrapInboundOut(_ value: Self.InboundOut) -> NIOCore.NIOAny
  public static func unwrapInboundIn(_ value: NIOCore.NIOAny) -> Self.InboundIn
  public static func wrapInboundOut(_ value: Self.InboundOut) -> NIOCore.NIOAny
}
public protocol ChannelOutboundHandler : NIOCore._ChannelOutboundHandler, NIOCore._EmittingChannelHandler {
  associatedtype OutboundIn
  func unwrapOutboundIn(_ value: NIOCore.NIOAny) -> Self.OutboundIn
}
extension NIOCore.ChannelOutboundHandler {
  public func unwrapOutboundIn(_ value: NIOCore.NIOAny) -> Self.OutboundIn
  public static func unwrapOutboundIn(_ value: NIOCore.NIOAny) -> Self.OutboundIn
}
public typealias ChannelDuplexHandler = NIOCore.ChannelInboundHandler & NIOCore.ChannelOutboundHandler
public protocol NIOClientTCPBootstrapProtocol {
  @preconcurrency func channelInitializer(_ handler: @escaping @Sendable (any NIOCore.Channel) -> NIOCore.EventLoopFuture<Swift.Void>) -> Self
  @preconcurrency func protocolHandlers(_ handlers: @escaping @Sendable () -> [any NIOCore.ChannelHandler]) -> Self
  func channelOption<Option>(_ option: Option, value: Option.Value) -> Self where Option : NIOCore.ChannelOption
  func _applyChannelConvenienceOptions(_ options: inout NIOCore.ChannelOptions.TCPConvenienceOptions) -> Self
  func connectTimeout(_ timeout: NIOCore.TimeAmount) -> Self
  func connect(host: Swift.String, port: Swift.Int) -> NIOCore.EventLoopFuture<any NIOCore.Channel>
  func connect(to address: NIOCore.SocketAddress) -> NIOCore.EventLoopFuture<any NIOCore.Channel>
  func connect(unixDomainSocketPath: Swift.String) -> NIOCore.EventLoopFuture<any NIOCore.Channel>
}
public struct NIOClientTCPBootstrap {
  public let underlyingBootstrap: any NIOCore.NIOClientTCPBootstrapProtocol
  public init<Bootstrap, TLS>(_ bootstrap: Bootstrap, tls: TLS) where Bootstrap : NIOCore.NIOClientTCPBootstrapProtocol, Bootstrap == TLS.Bootstrap, TLS : NIOCore.NIOClientTLSProvider
  public func channelInitializer(_ handler: @escaping @Sendable (any NIOCore.Channel) -> NIOCore.EventLoopFuture<Swift.Void>) -> NIOCore.NIOClientTCPBootstrap
  public func channelOption<Option>(_ option: Option, value: Option.Value) -> NIOCore.NIOClientTCPBootstrap where Option : NIOCore.ChannelOption
  public func connectTimeout(_ timeout: NIOCore.TimeAmount) -> NIOCore.NIOClientTCPBootstrap
  public func connect(host: Swift.String, port: Swift.Int) -> NIOCore.EventLoopFuture<any NIOCore.Channel>
  public func connect(to address: NIOCore.SocketAddress) -> NIOCore.EventLoopFuture<any NIOCore.Channel>
  public func connect(unixDomainSocketPath: Swift.String) -> NIOCore.EventLoopFuture<any NIOCore.Channel>
  @discardableResult
  public func enableTLS() -> NIOCore.NIOClientTCPBootstrap
}
public protocol NIOClientTLSProvider {
  associatedtype Bootstrap
  func enableTLS(_ bootstrap: Self.Bootstrap) -> Self.Bootstrap
}
public struct NIOInsecureNoTLS<Bootstrap> : NIOCore.NIOClientTLSProvider where Bootstrap : NIOCore.NIOClientTCPBootstrapProtocol {
  public init()
  public func enableTLS(_ bootstrap: Bootstrap) -> Bootstrap
}
public enum System {
  public static var coreCount: Swift.Int {
    get
  }
  @available(*, deprecated, renamed: "enumerateDevices")
  public static func enumerateInterfaces() throws -> [NIOCore.NIONetworkInterface]
  public static func enumerateDevices() throws -> [NIOCore.NIONetworkDevice]
}
extension NIOCore.System {
  public static let supportsUDPSegmentationOffload: Swift.Bool
  public static let supportsUDPReceiveOffload: Swift.Bool
  public static var udpMaxSegments: Swift.Int? {
    get
  }
}
extension NIOCore.Endianness : Swift.Equatable {}
extension NIOCore.Endianness : Swift.Hashable {}
extension NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength : Swift.Equatable {}
extension NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength : Swift.Hashable {}
extension NIOCore.ByteBuffer.QUICBinaryEncodingStrategy.IntegerLength : Swift.RawRepresentable {}
extension NIOCore.ChannelEvent : Swift.Hashable {}
extension NIOCore.IdleStateHandler.IdleStateEvent : Swift.Equatable {}
extension NIOCore.IdleStateHandler.IdleStateEvent : Swift.Hashable {}
extension NIOCore.CloseMode : Swift.Equatable {}
extension NIOCore.CloseMode : Swift.Hashable {}
extension NIOCore.ChannelPipelineError : Swift.Equatable {}
extension NIOCore.ChannelPipelineError : Swift.Hashable {}
extension NIOCore.DecodingState : Swift.Equatable {}
extension NIOCore.DecodingState : Swift.Hashable {}
extension NIOCore.EventLoopError : Swift.Equatable {}
extension NIOCore.EventLoopError : Swift.Hashable {}
